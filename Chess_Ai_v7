//mobility, hanging_w í•˜í•œì„  ì„¤ì •

let aiColor = 'black'; // AIì˜ í˜„ì¬ ê²Œì„ ìƒ‰ìƒ (ê¸°ë³¸ê°’: í‘)
let aiPlayedBlackLastGame = true; // AIê°€ ë§ˆì§€ë§‰ ê²Œì„ì—ì„œ í‘ì„ ì¡ì•˜ëŠ”ì§€ ì—¬ë¶€

const board = document.getElementById('chessboard');
const resetButton = document.getElementById('reset');
const whiteCapturedStorage = document.getElementById('whiteCapturedPieces');
const blackCapturedStorage = document.getElementById('blackCapturedPieces');
const statusDisplay = document.getElementById('status');

let selectedCell = null;
let selectedStorageCell = null;
let currentTurn = 'white'; // í•­ìƒ ë°±ì´ ë¨¼ì € ì‹œì‘
let gameOver = false;
let moveHistory = [];
let highlightedCells = [];
let internalBoardState = Array(8).fill().map(() => Array(8).fill(null));

let timers = {
    white: 600, // ì´ˆ ë‹¨ìœ„
    black: 600,
    interval: null,
    mode: 'none', // 'none', 'fisher', 'delay'
    base: 600,
    increment: 5,
    currentDelay: 0
};

// [ìƒë‹¨ ë³€ìˆ˜ ì„ ì–¸ë¶€]
let useOpeningBook = true; // ì˜¤í”„ë‹ ë¶ ì‚¬ìš© ì—¬ë¶€ ê¸°ë³¸ê°’: ì¼¬

// íƒìƒ‰ ì¤‘ì¸ ê²½ë¡œì˜ í•´ì‹œë¥¼ ì €ì¥í•  ìŠ¤íƒ
let searchStackHashes = [];

let positionHistory = new Map(); // 3íšŒ ë°˜ë³µì„ ê¸°ë¡í•˜ê¸° ìœ„í•œ í•´ì‹œ ë§µ

// [ì„¤ì •] ë¬´ìŠ¹ë¶€ ìˆ˜ ê°•ì¡° í‘œì‹œ ì—¬ë¶€ (true: ì¼¬, false: ë”)
let showDrawWarnings = true; 
let resultRecorded = false; // ì¶”ê°€: ê²Œì„ ê²°ê³¼ê°€ ì´ë¯¸ ê¸°ë¡ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í”Œë˜ê·¸

let gameMode = 'ai'; // 'ai' ë˜ëŠ” 'pvp'
const aiMatchBtn = document.getElementById('aiMatchBtn');
const pvpMatchBtn = document.getElementById('pvpMatchBtn');

let middlegame_depth = 3;
let endgame_depth = 5;
const ENDGAME_MATERIAL_THRESHOLD = 30;

/////////////////
// --- ğŸ¤– AI Self-Play Control ---
let isSelfPlayMode = false;
let selfPlayDelay = 200; // ëŒ€êµ­ ì†ë„ (ms)

// [ì¶”ê°€] AIê°€ ì„ íƒí•œ ìˆ˜ì˜ ì •ì  í‰ê°€ ë°ì´í„°ë¥¼ ì„ì‹œ ì €ì¥í•  ì „ì—­ ë³€ìˆ˜
let aiPendingStaticEval = null;
let aiPendingSearchScore = null;   // [ì¶”ê°€] AIê°€ ê³„ì‚°í•œ ìµœì¢… ì ìˆ˜ ë³´ê´€
let aiPendingSearchDetails = null; // [ì¶”ê°€] AIê°€ ê³„ì‚°í•œ ì„¸ë¶€ ì§€í‘œ ë³´ê´€

let isEndgameDBEnabled = false; // Endgame DB(êµ­ë©´ í•™ìŠµ) ì €ì¥ ì—¬ë¶€
let isSelfTuningEnabled = true; // [ì¶”ê°€] ê°€ì¤‘ì¹˜ í•™ìŠµ í™œì„±í™” ì—¬ë¶€ (ê¸°ë³¸ê°’: ì¼¬)

// ìµœìƒë‹¨ ë³€ìˆ˜ ì„ ì–¸ë¶€
let kingPos = {
    white: [7, 4], // ì´ˆê¸° ìœ„ì¹˜ e1
    black: [0, 4]  // ì´ˆê¸° ìœ„ì¹˜ e8
};

let currentBoardHash = 0n; // í˜„ì¬ ë³´ë“œì˜ ì‹¤ì‹œê°„ í•´ì‹œê°’

// ì „ì  ì €ì¥ìš© ì „ì—­ ë³€ìˆ˜
let selfPlayResults = {
    white: 0,
    black: 0,
    draw: 0,
    totalCompleted: 0,
    targetGames: 0
};
///////////////

const pieces = {
    'P': 'â™™', 'R': 'â™–', 'N': 'â™˜', 'B': 'â™—', 'Q': 'â™•', 'K': 'â™”',
    'p': 'â™Ÿ', 'r': 'â™œ', 'n': 'â™', 'b': 'â™', 'q': 'â™›', 'k': 'â™š'
};

const pieceValues = {
    'P': 1, 'p': 1,
    'N': 3, 'n': 3,
    'B': 3, 'b': 3,
    'R': 5, 'r': 5,
    'Q': 9, 'q': 9,
    'K': 0, 'k': 0 // í‚¹ì˜ ì ìˆ˜ëŠ” ì¼ë°˜ì ìœ¼ë¡œ 0 ë˜ëŠ” ë§¤ìš° ë†’ê²Œ ì„¤ì • (ì¡íˆë©´ ê²Œì„ ë)
};

const pawnPositionValues = [
    [ 0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00], // 8ì—´
    [ 0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00], // 7ì—´ 
    [ 0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00], // 6ì—´ 
    [ 0.00,  0.05,  0.10,  0.35,  0.35,  0.10,  0.05,  0.00], // 5ì—´ (ìµœëŒ€ ì¤‘ì•™ í†µì œ ì ìˆ˜)
    [ 0.00,  0.00,  0.15,  0.30,  0.30,  0.15,  0.00,  0.00], // 4ì—´ (ì•ˆì •ì ì¸ ì¤‘ì•™ ì ìœ )
    [ 0.00,  0.05,  0.05,  0.00,  0.00,  0.05,  0.05,  0.00], // 3ì—´ (ì†Œí­ ê°€ì )
    [ 0.00,  0.00,  0.00, -0.20, -0.20,  0.00,  0.00,  0.00], // 2ì—´ (ì¤‘ì•™ í° ë¹ ë¥¸ ì „ê°œ ìœ ë„)
    [ 0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00,  0.00]  // 1ì—´
];

const createBoard = () => {
    board.innerHTML = "";
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
          
            // ì§ì ‘ ìƒ‰ìƒì„ ë„£ëŠ” ëŒ€ì‹  í´ë˜ìŠ¤ë§Œ ë¶€ì—¬
            const isDark = (row + col) % 2 !== 0; 
            cell.classList.add(isDark ? 'dark' : 'light');
          
            cell.dataset.row = row;
            cell.dataset.col = col;
            cell.addEventListener('click', () => handleCellClick(cell));
            //cell.style.backgroundColor = (row + col) % 2 === 0 ? '#779556' : '#ebecd0';
            board.appendChild(cell);
        }
    }
};

// ë³´ê´€ì†Œ ì…€ ìƒì„±
const createStorageCells = (storageElement) => {
    storageElement.innerHTML = '';
    for (let i = 0; i < 16; i++) {
        const cell = document.createElement('div');
        cell.classList.add('storage-cell');
        cell.dataset.index = i;
        cell.addEventListener('click', () => handleStorageCellClick(cell));
        storageElement.appendChild(cell);
    }
};

//ê¸°ë¬¼ ìƒì„± (ìœ ë‹ˆì½”ë“œ ë¬¸ì ì‚¬ìš©)
const createPiece = (char) => {
    const span = document.createElement('span');
    span.textContent = pieces[char];
    span.dataset.piece = char;
    span.classList.add('piece');
    span.style.fontSize = '40px'; // ê¸°ë¬¼ í¬ê¸°
    span.style.lineHeight = '60px'; // ì…€ ì¤‘ì•™ ì •ë ¬
    return span;
};

// ì´ˆê¸° ê¸°ë¬¼ ë°°ì¹˜
const initPieces = () => {
    const setup = [
        ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
        ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
        [], [], [], [],
        ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
        ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
    ];

    const cells = document.querySelectorAll('.cell');
    cells.forEach(cell => cell.innerHTML = ''); // Clear existing pieces first

    setup.forEach((row, rowIndex) => {
        row.forEach((piece, colIndex) => {
            if (piece) {
                const cellIndex = rowIndex * 8 + colIndex;
                 if (cellIndex < cells.length) {
                    cells[cellIndex].appendChild(createPiece(piece));
                 }
            }
        });
    });
};

// ë³´ê´€ì†Œ ì´ˆê¸°í™”
const initStorageAreas = () => {
    createStorageCells(whiteCapturedStorage);
    createStorageCells(blackCapturedStorage);
};

// ì²´ìŠ¤íŒ ìƒíƒœë¥¼ ë°°ì—´ë¡œ ë³€í™˜
const getBoardState = () => {
    const state = Array(8).fill().map(() => Array(8).fill(null));
    const cells = document.querySelectorAll('.cell');
    cells.forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        if (cell.firstChild) {
            state[row][col] = cell.firstChild.dataset.piece;
        }
    });
    return state;
};

// íŠ¹ì • ìœ„ì¹˜ì˜ ì…€ ê°€ì ¸ì˜¤ê¸°
const getCell = (row, col) => {
    if (row < 0 || row > 7 || col < 0 || col > 7) return null;
    return document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
};

// íŠ¹ì • ìœ„ì¹˜ì˜ ê¸°ë¬¼ í™•ì¸
const getPieceAt = (row, col, boardState = null) => {
    boardState = boardState || internalBoardState; // Use internal state by default
    if (row < 0 || row > 7 || col < 0 || col > 7) return null;
    return boardState[row][col];
};


// ê¸°ë¬¼ë³„ ì´ë™ ê°€ëŠ¥ ìœ„ì¹˜ ê³„ì‚° (ìºìŠ¬ë§ê³¼ ì•™íŒŒìƒ ìˆ˜ì •)
const getValidMoves = (piece, row, col, boardState = null, skipCastlingCheck = false) => {
    const moves = [];
    const isWhite = piece === piece.toUpperCase();
    boardState = boardState || internalBoardState; // Use internal state if none provided

    switch (piece.toUpperCase()) {
        case 'P': // í°
            const direction = isWhite ? -1 : 1;
            const startRow = isWhite ? 6 : 1;
            const promotionRow = isWhite ? 0 : 7;

            // 1ì¹¸ ì „ì§„
            if (row + direction >= 0 && row + direction <= 7 && getPieceAt(row + direction, col, boardState) === null) {
                moves.push([row + direction, col]);
                // 2ì¹¸ ì „ì§„ (ì‹œì‘ ìœ„ì¹˜ì—ì„œë§Œ)
                if (row === startRow && getPieceAt(row + 2 * direction, col, boardState) === null) {
                    moves.push([row + 2 * direction, col]);
                }
            }
            // ëŒ€ê°ì„  ê³µê²©
            if (col > 0 && getPieceAt(row + direction, col - 1, boardState) &&
                (isWhite !== (getPieceAt(row + direction, col - 1, boardState) === getPieceAt(row + direction, col - 1, boardState).toUpperCase()))) {
                moves.push([row + direction, col - 1]);
            }
            if (col < 7 && getPieceAt(row + direction, col + 1, boardState) &&
                (isWhite !== (getPieceAt(row + direction, col + 1, boardState) === getPieceAt(row + direction, col + 1, boardState).toUpperCase()))) {
                moves.push([row + direction, col + 1]);
            }
            // ì•™íŒŒìƒ
            const enPassantRow = isWhite ? 3 : 4;
            if (row === enPassantRow && moveHistory.length > 0) {
                const lastMove = moveHistory[moveHistory.length - 1];
                // lastMove.from/to might be DOM elements or objects depending on history implementation. Ensure we get row/col data.
                const lastFromRow = parseInt(lastMove.from.dataset?.row ?? lastMove.from.row); // Adapt based on history structure
                const lastFromCol = parseInt(lastMove.from.dataset?.col ?? lastMove.from.col);
                const lastToRow = parseInt(lastMove.to.dataset?.row ?? lastMove.to.row);
                const lastToCol = parseInt(lastMove.to.dataset?.col ?? lastMove.to.col);
                const lastPiece = lastMove.pieceMoved ?? lastMove.piece ?? (lastMove.to.firstChild ? lastMove.to.firstChild.dataset.piece : null); // Adapt based on history structure

                if (lastPiece && lastPiece.toUpperCase() === 'P' && Math.abs(lastFromRow - lastToRow) === 2 && lastToRow === row && Math.abs(lastToCol - col) === 1) {
                    moves.push([row + direction, lastToCol, 'enPassant']);
                }
            }
            break;

        case 'R': // ë£¨í¬
            for (let dir of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {
                let newRow = row, newCol = col;
                while (true) {
                    newRow += dir[0];
                    newCol += dir[1];
                    if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                    const pieceAtPos = getPieceAt(newRow, newCol, boardState);
                    if (pieceAtPos) {
                        if (isWhite !== (pieceAtPos === pieceAtPos.toUpperCase())) { // ë‹¤ë¥¸ ìƒ‰ ê¸°ë¬¼
                            moves.push([newRow, newCol]);
                        }
                        break; // ê°™ì€ ìƒ‰ ë˜ëŠ” ë‹¤ë¥¸ ìƒ‰ ê¸°ë¬¼ ë§Œë‚˜ë©´ ë©ˆì¶¤
                    }
                    moves.push([newRow, newCol]); // ë¹ˆ ì¹¸
                }
            }
            break;

        case 'N': // ë‚˜ì´íŠ¸
            const knightMoves = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];
            for (let [dr, dc] of knightMoves) {
                const newRow = row + dr, newCol = col + dc;
                if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) continue;
                const pieceAtPos = getPieceAt(newRow, newCol, boardState);
                if (!pieceAtPos || (isWhite !== (pieceAtPos === pieceAtPos.toUpperCase()))) { // ë¹„ì–´ìˆê±°ë‚˜ ë‹¤ë¥¸ ìƒ‰ ê¸°ë¬¼
                    moves.push([newRow, newCol]);
                }
            }
            break;

        case 'B': // ë¹„ìˆ
             for (let dir of [[1, 1], [1, -1], [-1, 1], [-1, -1]]) {
                let newRow = row, newCol = col;
                while (true) {
                    newRow += dir[0];
                    newCol += dir[1];
                    if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                    const pieceAtPos = getPieceAt(newRow, newCol, boardState);
                    if (pieceAtPos) {
                        if (isWhite !== (pieceAtPos === pieceAtPos.toUpperCase())) {
                            moves.push([newRow, newCol]);
                        }
                        break;
                    }
                    moves.push([newRow, newCol]);
                }
            }
            break;

        case 'Q': // í€¸
            for (let dir of [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]) {
                let newRow = row, newCol = col;
                while (true) {
                    newRow += dir[0];
                    newCol += dir[1];
                    if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                    const pieceAtPos = getPieceAt(newRow, newCol, boardState);
                    if (pieceAtPos) {
                        if (isWhite !== (pieceAtPos === pieceAtPos.toUpperCase())) {
                            moves.push([newRow, newCol]);
                        }
                        break;
                    }
                    moves.push([newRow, newCol]);
                }
            }
            break;

        case 'K': // í‚¹
            const kingMoves = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1], [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];
            for (let [dr, dc] of kingMoves) {
                const newRow = row + dr, newCol = col + dc;
                if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) continue;
                const pieceAtPos = getPieceAt(newRow, newCol, boardState);
                 // ì´ë™í•˜ë ¤ëŠ” ì¹¸ì´ ê³µê²©ë°›ëŠ”ì§€ ì—¬ë¶€ëŠ” isMoveValidì—ì„œ ì²´í¬
                if (!pieceAtPos || (isWhite !== (pieceAtPos === pieceAtPos.toUpperCase()))) {
                    moves.push([newRow, newCol]);
                }
            }
             // ìºìŠ¬ë§ (ì¬ê·€ ë°©ì§€ ë° isSquareAttacked ì‚¬ìš© ë‹¨ìˆœí™”)
            // ìºìŠ¬ë§ (skipCastlingCheck í”Œë˜ê·¸ëŠ” isSquareAttacked ì¬ê·€ í˜¸ì¶œ ë°©ì§€ìš©ìœ¼ë¡œ ìœ ì§€)
            if (!skipCastlingCheck) {
                const kingStartRow = isWhite ? 7 : 0;
                // ì¡°ê±´ 0: í‚¹ì´ ì‹œì‘ ìœ„ì¹˜ì— ìˆì–´ì•¼ í•¨
                if (row === kingStartRow && col === 4) {
                    // ì¡°ê±´ 1: í˜„ì¬ ì²´í¬ ìƒíƒœê°€ ì•„ë‹ˆì–´ì•¼ í•¨ (ê°€ì¥ ë¨¼ì € í™•ì¸!)
                    if (!isInCheck(isWhite ? 'white' : 'black', boardState)) {
                        // í‚¹/ë£© ì´ë™ ì—¬ë¶€ ì²´í¬ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
                        const kingMoved = moveHistory.some(m => (m.pieceMoved ?? m.piece)?.toUpperCase() === 'K' && m.from.row === kingStartRow && m.from.col === 4);

                        if (!kingMoved) {
                            // í‚¹ì‚¬ì´ë“œ ìºìŠ¬ë§ (híŒŒì¼ ë£©)
                            const rookKingSideCol = 7;
                            const rookKingSideMoved = moveHistory.some(m => (m.pieceMoved ?? m.piece)?.toUpperCase() === 'R' && m.from.row === kingStartRow && m.from.col === rookKingSideCol);
                            // ì¡°ê±´: í•´ë‹¹ ìœ„ì¹˜ì— ë£©ì´ ìˆê³ , ë£©ì´ ì›€ì§ì¸ ì  ì—†ì–´ì•¼ í•¨
                            if (getPieceAt(kingStartRow, rookKingSideCol, boardState)?.toUpperCase() === 'R' && !rookKingSideMoved) {
                                // ì¡°ê±´: ê²½ë¡œê°€ ë¹„ì–´ìˆì–´ì•¼ í•¨ (f, g íŒŒì¼)
                                if (getPieceAt(kingStartRow, 5, boardState) === null && getPieceAt(kingStartRow, 6, boardState) === null) {
                                    // ì¡°ê±´: í‚¹ì´ í†µê³¼í•˜ëŠ” ì¹¸(fíŒŒì¼)ê³¼ ë„ì°©í•˜ëŠ” ì¹¸(gíŒŒì¼)ì´ ê³µê²©ë°›ì§€ ì•Šì•„ì•¼ í•¨
                                    // (ì‹œì‘ ì¹¸(eíŒŒì¼)ì€ ì´ë¯¸ ìœ„ì—ì„œ ì²´í¬ ìƒíƒœ ì•„ë‹˜ì„ í™•ì¸)
                                    if (!isSquareAttacked(kingStartRow, 5, isWhite ? 'white' : 'black', boardState) &&
                                        !isSquareAttacked(kingStartRow, 6, isWhite ? 'white' : 'black', boardState)) {
                                        moves.push([kingStartRow, 6, 'castling']); // ìºìŠ¬ë§ ì´ë™ ì œì•ˆ
                                    }
                                }
                            }

                            // í€¸ì‚¬ì´ë“œ ìºìŠ¬ë§ (aíŒŒì¼ ë£©)
                            const rookQueenSideCol = 0;
                            const rookQueenSideMoved = moveHistory.some(m => (m.pieceMoved ?? m.piece)?.toUpperCase() === 'R' && m.from.row === kingStartRow && m.from.col === rookQueenSideCol);
                            // ì¡°ê±´: í•´ë‹¹ ìœ„ì¹˜ì— ë£©ì´ ìˆê³ , ë£©ì´ ì›€ì§ì¸ ì  ì—†ì–´ì•¼ í•¨
                            if (getPieceAt(kingStartRow, rookQueenSideCol, boardState)?.toUpperCase() === 'R' && !rookQueenSideMoved) {
                                // ì¡°ê±´: ê²½ë¡œê°€ ë¹„ì–´ìˆì–´ì•¼ í•¨ (b, c, d íŒŒì¼)
                                if (getPieceAt(kingStartRow, 1, boardState) === null && getPieceAt(kingStartRow, 2, boardState) === null && getPieceAt(kingStartRow, 3, boardState) === null) {
                                    // ì¡°ê±´: í‚¹ì´ í†µê³¼í•˜ëŠ” ì¹¸(c, díŒŒì¼)ê³¼ ë„ì°©í•˜ëŠ” ì¹¸(cíŒŒì¼)ì´ ê³µê²©ë°›ì§€ ì•Šì•„ì•¼ í•¨
                                    // (ì‹œì‘ ì¹¸(eíŒŒì¼)ì€ ì´ë¯¸ ìœ„ì—ì„œ ì²´í¬ ìƒíƒœ ì•„ë‹˜ì„ í™•ì¸)
                                    if (!isSquareAttacked(kingStartRow, 2, isWhite ? 'white' : 'black', boardState) &&
                                        !isSquareAttacked(kingStartRow, 3, isWhite ? 'white' : 'black', boardState)) {
                                        // ì°¸ê³ : í‚¹ì´ ìµœì¢… ë„ì°©í•˜ëŠ” cíŒŒì¼(2ì—´)ì´ ê³µê²©ë°›ëŠ”ì§€ëŠ” isSquareAttackedì—ì„œ í™•ì¸ë¨.
                                        moves.push([kingStartRow, 2, 'castling']); // ìºìŠ¬ë§ ì´ë™ ì œì•ˆ
                                    }
                                }
                            }
                        }
                    }
                }
            }
            break; // í‚¹ ì¼€ì´ìŠ¤ ì¢…ë£Œ
    }

    // Filter out moves that leave the king in check
    const validFilteredMoves = [];
    for (const move of moves) {
         const [toRow, toCol] = move;
         if (isMoveValid(row, col, toRow, toCol, piece, isWhite ? 'white' : 'black', boardState, move[2])) {
              validFilteredMoves.push(move);
         }
     }
     // console.log(`Piece ${piece} at ${row},${col} has moves:`, moves, `Valid moves:`, validFilteredMoves);
     return validFilteredMoves; // Return only legally valid moves
};

// ì´ˆê¸°í™” ì‹œ internalBoardState ì„¤ì •
const initInternalBoardState = () => {
    const setup = [
        ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
        ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
        Array(8).fill(null), Array(8).fill(null), Array(8).fill(null), Array(8).fill(null), // Empty rows
        ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
        ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
    ];
     // Deep copy setup to internalBoardState
    internalBoardState = JSON.parse(JSON.stringify(setup));
};

// ì´ë™ ì‹œ internalBoardState ì—…ë°ì´íŠ¸ (ìºìŠ¬ë§, ì•™íŒŒìƒ í¬í•¨)
const updateInternalBoardState = (fromRow, fromCol, toRow, toCol, piece, specialMove = null) => {
    internalBoardState[toRow][toCol] = piece;
    internalBoardState[fromRow][fromCol] = null;

    if (specialMove === 'enPassant') {
        const capturedPawnRow = fromRow; // ì•™íŒŒìƒìœ¼ë¡œ ì¡íŒ í°ì€ ì´ë™í•œ í°ê³¼ ê°™ì€ í–‰ì— ìˆìŒ
        const capturedPawnCol = toCol;
        internalBoardState[capturedPawnRow][capturedPawnCol] = null;
    } else if (specialMove === 'castling') {
        const rookFromCol = toCol === 6 ? 7 : 0; // í‚¹ì‚¬ì´ë“œë©´ 7, í€¸ì‚¬ì´ë“œë©´ 0
        const rookToCol = toCol === 6 ? 5 : 3;   // í‚¹ì‚¬ì´ë“œë©´ 5, í€¸ì‚¬ì´ë“œë©´ 3
        const rookPiece = internalBoardState[fromRow][rookFromCol];
        internalBoardState[fromRow][rookToCol] = rookPiece;
        internalBoardState[fromRow][rookFromCol] = null;
    }
     // Check promotion after move for internal state
     checkPromotionInternal(toRow, toCol, piece, internalBoardState); 
};

// ë‚´ë¶€ ìƒíƒœ í° ìŠ¹ê¸‰ ì²˜ë¦¬ (AIìš©, ìë™ í€¸ ìŠ¹ê¸‰)
const checkPromotionInternal = (row, col, piece, targetBoard) => {
    if (!piece) return;
    const isWhite = piece === piece.toUpperCase();
    const promotionRow = isWhite ? 0 : 7;
    
    if (piece.toUpperCase() === 'P' && row === promotionRow) {
        // ì „ì—­ ë³€ìˆ˜ê°€ ì•„ë‹Œ, ì¸ìë¡œ ë°›ì€ ë³´ë“œë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤.
        targetBoard[row][col] = isWhite ? 'Q' : 'q'; 
    }
};

// ìŠ¹ê¸‰ ìƒí™©ì¸ì§€ í™•ì¸í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
const isPromotionSituation = (piece, toRow) => {
    if (!piece) return false;
    const isWhitePawn = piece === 'P' && toRow === 0;
    const isBlackPawn = piece === 'p' && toRow === 7;
    return isWhitePawn || isBlackPawn;
};

const transpositionTable = new Map();

//////////////
// [ìˆ˜ì •] 64ë¹„íŠ¸ ê²°ì •ì„ ìœ„í•œ BigInt ë‚œìˆ˜ ìƒì„±ê¸°
function seededRandom64(seed) {
    let state = BigInt(seed);
    return function() {
        // SplitMix64 ì•Œê³ ë¦¬ì¦˜ ìŠ¤íƒ€ì¼ (BigInt ì „ìš©)
        state += 0x9e3779b97f4a7c15n;
        let z = state;
        z = (z ^ (z >> 30n)) * 0xbf58476d1ce4e5b9n;
        z = (z ^ (z >> 27n)) * 0x94d049bb133111ebn;
        return z ^ (z >> 31n);
    };
}

const MY_SEED = 5082098860154493; // ì‚¬ìš©ìë‹˜ì˜ ê³ ì • ì‹œë“œ
const nextRand64 = seededRandom64(MY_SEED);

// ëª¨ë“  í‚¤ë¥¼ BigIntë¡œ ìƒì„±
const zobristKeys = Array(8).fill().map(() =>
    Array(8).fill().map(() =>
        Array(12).fill().map(() => nextRand64())
    )
);

const turnKey = nextRand64();
const castleKeys = Array(4).fill().map(() => nextRand64());
const enPassantKeys = Array(8).fill().map(() => nextRand64());
//////////////

const pieceToIndex = (piece) => {
    const piecesList = ['P', 'R', 'N', 'B', 'Q', 'K', 'p', 'r', 'n', 'b', 'q', 'k'];
    return piecesList.indexOf(piece);
};

const killerMoves = Array(10).fill().map(() => []); // ìµœëŒ€ ê¹Šì´ 10
const historyTable = {}; // [piece][to_sq] -> score

// ì´ë™ ìš°ì„ ìˆœìœ„ ê³„ì‚° (ê°„ë‹¨í™”ëœ ë²„ì „)
const getMovePriority = (move, boardState, depth) => {
    let priority = 0;
    const targetPiece = boardState[move.to[0]][move.to[1]];

    // MVV-LVA (Most Valuable Victim - Least Valuable Aggressor)
    if (targetPiece) {
        priority += 10 * pieceValues[targetPiece] - pieceValues[move.piece];
    }

    // Killer Moves
    if (killerMoves[depth]?.some(m => m.from[0] === move.from[0] && m.from[1] === move.from[1] && m.to[0] === move.to[0] && m.to[1] === move.to[1])) {
        priority += 50;
    }

    // History Heuristic (simple version)
    const historyKey = `${move.piece}_${move.to[0]}_${move.to[1]}`;
     priority += historyTable[historyKey] || 0;

     // Promotion boost
     if (move.piece.toUpperCase() === 'P') {
         const promotionRow = (move.piece === 'P') ? 0 : 7;
         if (move.to[0] === promotionRow) {
             priority += pieceValues['Q'] * 10; // Prioritize promotion to queen
         }
     }
  /////////////
    if (move.to[2] === 'castling') {
    priority += 150; // ìºìŠ¬ë§ ì´ë™ì„ ìµœìš°ì„  ìˆœìœ„ ì¤‘ í•˜ë‚˜ë¡œ ì„¤ì •
}
  ////////////
    return priority;
};

// ì´ë™ ì •ë ¬
const sortMoves = (moves, boardState, depth) => {
    // Calculate priorities first
    const movesWithPriority = moves.map(move => ({
        move,
        priority: getMovePriority(move, boardState, depth)
    }));

    // Sort in descending order of priority
    movesWithPriority.sort((a, b) => b.priority - a.priority);

    // Return just the moves in sorted order
    return movesWithPriority.map(item => item.move);
};

// ê°€ëŠ¥í•œ ëª¨ë“  ì´ë™ ìƒì„± (íŠ¹ì • ìƒ‰ìƒ)
const getPossibleMoves = (boardState, color) => {
    const moves = [];
    const isWhiteTurn = color === 'white';
    const kingStartRow = isWhiteTurn ? 7 : 0;

    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = boardState[row][col];
            if (piece && ((isWhiteTurn && piece === piece.toUpperCase()) ||
                          (!isWhiteTurn && piece === piece.toLowerCase()))) {
                
                const potentialMoves = getValidMoves_Raw(piece, row, col, boardState);
                potentialMoves.forEach(move => {
                    moves.push({ from: [row, col], to: move, piece: piece });
                });

                // --- [ì—¬ê¸°ì„œ ìºìŠ¬ë§ ìˆ˜ë™ ì¶”ê°€] ---
                if (piece.toUpperCase() === 'K' && row === kingStartRow && col === 4) {
                    // ê¸°ë³¸ ê²½ë¡œ ì ê²€ (ê¸°ë¬¼ ì¡´ì¬ ì—¬ë¶€ë§Œ)
                    if (getPieceAt(row, 5, boardState) === null && getPieceAt(row, 6, boardState) === null && getPieceAt(row, 7, boardState)?.toUpperCase() === 'R') {
                        moves.push({ from: [row, 4], to: [row, 6, 'castling'], piece: piece });
                    }
                    if (getPieceAt(row, 1, boardState) === null && getPieceAt(row, 2, boardState) === null && getPieceAt(row, 3, boardState) === null && getPieceAt(row, 0, boardState)?.toUpperCase() === 'R') {
                        moves.push({ from: [row, 4], to: [row, 2, 'castling'], piece: piece });
                    }
                }
            }
        }
    }
    return moves;
};


// Raw move generation without check validation (for isSquareAttacked)
const getValidMoves_Raw = (piece, row, col, boardState) => {
     const moves = [];
    const isWhite = piece === piece.toUpperCase();

     switch (piece.toUpperCase()) {
         case 'P':
             const direction = isWhite ? -1 : 1;
             const startRow = isWhite ? 6 : 1;
              // 1ì¹¸ ì „ì§„ (ë³´ë“œ ë²”ìœ„ ì²´í¬ í•„ìˆ˜)
              if (row + direction >= 0 && row + direction < 8 && getPieceAt(row + direction, col, boardState) === null) {
                 moves.push([row + direction, col]);
                 // 2ì¹¸ ì „ì§„
                 if (row === startRow && getPieceAt(row + 2 * direction, col, boardState) === null) {
                     moves.push([row + 2 * direction, col]);
                 }
             }
              // ëŒ€ê°ì„  ê³µê²© (ë³´ë“œ ë²”ìœ„ ì²´í¬ í•„ìˆ˜)
              if (col > 0 && row + direction >=0 && row+direction < 8) {
                  const targetPiece = getPieceAt(row + direction, col - 1, boardState);
                  if(targetPiece && (isWhite !== (targetPiece === targetPiece.toUpperCase()))) {
                      moves.push([row + direction, col - 1]);
                  }
              }
               if (col < 7 && row + direction >=0 && row+direction < 8) {
                    const targetPiece = getPieceAt(row + direction, col + 1, boardState);
                   if(targetPiece && (isWhite !== (targetPiece === targetPiece.toUpperCase()))) {
                       moves.push([row + direction, col + 1]);
                   }
               }
                // ì•™íŒŒìƒ (ë¡œì§ì€ getValidMovesì™€ ë™ì¼í•˜ê²Œ ìœ ì§€ ê°€ëŠ¥)
                 const enPassantRow = isWhite ? 3 : 4;
                 if (row === enPassantRow && moveHistory.length > 0) {
                     const lastMove = moveHistory[moveHistory.length - 1];
                     const lastFromRow = parseInt(lastMove.from.dataset?.row ?? lastMove.from.row);
                     const lastFromCol = parseInt(lastMove.from.dataset?.col ?? lastMove.from.col);
                     const lastToRow = parseInt(lastMove.to.dataset?.row ?? lastMove.to.row);
                     const lastToCol = parseInt(lastMove.to.dataset?.col ?? lastMove.to.col);
                     const lastPiece = lastMove.pieceMoved ?? lastMove.piece ?? (lastMove.to.firstChild ? lastMove.to.firstChild.dataset.piece : null);

                      if (lastPiece && lastPiece.toUpperCase() === 'P' && Math.abs(lastFromRow - lastToRow) === 2 && lastToRow === row && Math.abs(lastToCol - col) === 1) {
                         // Check if landing square is valid
                          if (row + direction >= 0 && row + direction < 8 && lastToCol >= 0 && lastToCol < 8) {
                             moves.push([row + direction, lastToCol, 'enPassant']);
                         }
                     }
                 }
             break;
          case 'R':
             for (let dir of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {
                 let newRow = row, newCol = col;
                 while (true) {
                     newRow += dir[0];
                     newCol += dir[1];
                     if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                     const pieceAtPos = getPieceAt(newRow, newCol, boardState);
                     if (pieceAtPos) {
                         if (isWhite !== (pieceAtPos === pieceAtPos.toUpperCase())) { moves.push([newRow, newCol]); }
                         break;
                     }
                     moves.push([newRow, newCol]);
                 }
             }
             break;
         case 'N':
             const knightMoves = [ [-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1] ];
             for (let [dr, dc] of knightMoves) {
                 const newRow = row + dr, newCol = col + dc;
                 if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) continue;
                 const pieceAtPos = getPieceAt(newRow, newCol, boardState);
                 if (!pieceAtPos || (isWhite !== (pieceAtPos === pieceAtPos.toUpperCase()))) { moves.push([newRow, newCol]); }
             }
             break;
         case 'B':
              for (let dir of [[1, 1], [1, -1], [-1, 1], [-1, -1]]) {
                 let newRow = row, newCol = col;
                 while (true) {
                     newRow += dir[0];
                     newCol += dir[1];
                     if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                     const pieceAtPos = getPieceAt(newRow, newCol, boardState);
                     if (pieceAtPos) {
                         if (isWhite !== (pieceAtPos === pieceAtPos.toUpperCase())) { moves.push([newRow, newCol]); }
                         break;
                     }
                     moves.push([newRow, newCol]);
                 }
             }
             break;
         case 'Q':
             for (let dir of [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]) {
                 let newRow = row, newCol = col;
                 while (true) {
                     newRow += dir[0];
                     newCol += dir[1];
                     if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
                     const pieceAtPos = getPieceAt(newRow, newCol, boardState);
                     if (pieceAtPos) {
                         if (isWhite !== (pieceAtPos === pieceAtPos.toUpperCase())) { moves.push([newRow, newCol]); }
                         break;
                     }
                     moves.push([newRow, newCol]);
                 }
             }
             break;
         case 'K':
             const kingMoves = [ [-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1] ];
             for (let [dr, dc] of kingMoves) {
                 const newRow = row + dr, newCol = col + dc;
                 if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) continue;
                 const pieceAtPos = getPieceAt(newRow, newCol, boardState);
                 if (!pieceAtPos || (isWhite !== (pieceAtPos === pieceAtPos.toUpperCase()))) { moves.push([newRow, newCol]); }
             }
             break;
     }
     return moves;
 }

const isSquareAttacked = (row, col, color, boardState) => {
    const isWhite = color === 'white';
    const oppPawn = isWhite ? 'p' : 'P';
    const oppKnight = isWhite ? 'n' : 'N';
    const oppBishop = isWhite ? 'b' : 'B';
    const oppRook = isWhite ? 'r' : 'R';
    const oppQueen = isWhite ? 'q' : 'Q';
    const oppKing = isWhite ? 'k' : 'K';

    // 1. ë‚˜ì´íŠ¸ ê³µê²© í™•ì¸ (Lì)
    const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
    for (const [dr, dc] of knightMoves) {
        const r = row + dr, c = col + dc;
        if (r >= 0 && r < 8 && c >= 0 && c < 8 && boardState[r][c] === oppKnight) return true;
    }

    // 2. ì§ì„  ê³µê²© (ë£¨í¬, í€¸)
    const rookDirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    for (const [dr, dc] of rookDirs) {
        let r = row + dr, c = col + dc;
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const piece = boardState[r][c];
            if (piece) {
                if (piece === oppRook || piece === oppQueen) return true;
                break; // ë‹¤ë¥¸ ê¸°ë¬¼ì´ ê°€ë¡œë§‰ìŒ
            }
            r += dr; c += dc;
        }
    }

    // 3. ëŒ€ê°ì„  ê³µê²© (ë¹„ìˆ, í€¸, í°)
    const bishopDirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
    for (const [dr, dc] of bishopDirs) {
        let r = row + dr, c = col + dc;
        // í° ê³µê²©ì€ ë”± í•œ ì¹¸ ê±°ë¦¬ì—ë§Œ ì¡´ì¬í•¨
        const pawnDir = isWhite ? -1 : 1; 
        if (r === row + pawnDir && (c === col - 1 || c === col + 1)) {
            if (boardState[r]?.[c] === oppPawn) return true;
        }

        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const piece = boardState[r][c];
            if (piece) {
                if (piece === oppBishop || piece === oppQueen) return true;
                break;
            }
            r += dr; c += dc;
        }
    }

    // 4. ìƒëŒ€ í‚¹ ê·¼ì ‘ í™•ì¸
    for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const r = row + dr, c = col + dc;
            if (r >= 0 && r < 8 && c >= 0 && c < 8 && boardState[r][c] === oppKing) return true;
        }
    }

    return false;
};

// í‚¹ì˜ ìœ„ì¹˜ ì°¾ê¸°
const findKing = (color, boardState) => {
    const kingPiece = color === 'white' ? 'K' : 'k';
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            if (boardState[row][col] === kingPiece) {
                return [row, col];
            }
        }
    }
    return null; // Should not happen in a normal game
};

// ì²´í¬ ìƒíƒœ í™•ì¸
///////////////
// ìµœì í™”ëœ isInCheck: ì „ì—­ kingPosë¥¼ ì§ì ‘ ì°¸ì¡°í•˜ì—¬ O(1) ë‹¬ì„±
const isInCheck = (color, boardState, optionalKingPos = null) => {
    // 1. ì¸ìë¡œ ë„˜ì–´ì˜¨ ì¢Œí‘œê°€ ìˆë‹¤ë©´ ê·¸ê²ƒì„ ì“°ê³ , ì—†ìœ¼ë©´ ì „ì—­ ë³€ìˆ˜ì—ì„œ ê°€ì ¸ì˜´
    const pos = optionalKingPos || (color === 'white' ? kingPos.white : kingPos.black);
    
    // 2. í‚¹ì´ ì—†ëŠ” ì˜ˆì™¸ ìƒí™© ì²˜ë¦¬ (ì´ˆê¸°í™” ë“±)
    if (!pos) return false; 
    
    // 3. ì¦‰ì‹œ ê³µê²© ì—¬ë¶€ í™•ì¸ (O(1) ê²€ìƒ‰)
    return isSquareAttacked(pos[0], pos[1], color, boardState);
};
///////////////

const isMoveValid = (fromRow, fromCol, toRow, toCol, piece, color, boardState, specialMove = null) => {
    if (!piece) return false;

    // --- [1] Make Move (ì„ì‹œ ì´ë™) ---
    const originalTargetPiece = boardState[toRow][toCol];
    let originalEnPassantPiece = null;

    boardState[toRow][toCol] = piece;
    boardState[fromRow][fromCol] = null;

    if (specialMove === 'enPassant') {
        originalEnPassantPiece = boardState[fromRow][toCol];
        boardState[fromRow][toCol] = null;
    } else if (specialMove === 'castling') {
        // ìºìŠ¬ë§ì€ ì´ë¯¸ getValidMovesì—ì„œ ê²½ë¡œ ì²´í¬ë¥¼ í•˜ë¯€ë¡œ, 
        // ì—¬ê¸°ì„  í‚¹ì´ ìµœì¢… ìœ„ì¹˜ì—ì„œ ì•ˆì „í•œì§€ë§Œ ë´ë„ ë¬´ë°©í•©ë‹ˆë‹¤. (ë£© ì´ë™ì€ ìƒëµ ê°€ëŠ¥)
    }
  
  /////////////////
    // ì›€ì§ì´ëŠ” ê¸°ë¬¼ì´ í‚¹ì´ë©´ ëª©ì ì§€(toRow, toCol)ê°€ ìƒˆë¡œìš´ ì¢Œí‘œ, ì•„ë‹ˆë©´ ê¸°ì¡´ ì „ì—­ ì¢Œí‘œ ìœ ì§€
    const simulatedKingPos = (piece.toUpperCase() === 'K') 
        ? [toRow, toCol] 
        : (color === 'white' ? kingPos.white : kingPos.black);

    // ìµœì í™”ëœ isInCheckì— ì‹œë®¬ë ˆì´ì…˜ëœ ì¢Œí‘œë¥¼ ì§ì ‘ ì°”ëŸ¬ë„£ì–´ ë£¨í”„ ë°©ì§€
    const isValid = !isInCheck(color, boardState, simulatedKingPos);
  ////////////////

    // --- [3] Unmake Move (ë³µêµ¬) ---
    boardState[fromRow][fromCol] = piece;
    boardState[toRow][toCol] = originalTargetPiece;

    if (specialMove === 'enPassant') {
        boardState[fromRow][toCol] = originalEnPassantPiece;
    }

    return isValid;
};

const getLegalMoves = (boardState, color) => {
    const legalMoves = [];
    const isWhite = color === 'white';

    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = boardState[row][col];
            if (!piece || (isWhite ? piece !== piece.toUpperCase() : piece !== piece.toLowerCase())) continue;

            // Raw Move(ê¸°ë³¸ ì´ë™ ë²•ì¹™) ìƒì„±
            const rawMoves = getValidMoves_Raw(piece, row, col, boardState);
            
            for (const move of rawMoves) {
                // moveëŠ” [toRow, toCol, special] í˜•íƒœ
                if (isMoveValid(row, col, move[0], move[1], piece, color, boardState, move[2])) {
                    legalMoves.push({
                        from: [row, col],
                        to: move,
                        piece: piece
                    });
                }
            }
        }
    }
    return legalMoves;
};

const checkIfMoveleadsToDraw = (fromRow, fromCol, toRow, toCol, piece, specialMove) => {
    // 1. ì„ì‹œ ë³´ë“œ ìƒì„± ë° ì´ë™ ì‹œë®¬ë ˆì´ì…˜
    const tempBoard = internalBoardState.map(row => [...row]);
    
    // ì´ë™ ì‹¤í–‰ (ì‹œë®¬ë ˆì´ì…˜)
    tempBoard[toRow][toCol] = piece;
    tempBoard[fromRow][fromCol] = null;
    if (specialMove === 'enPassant') tempBoard[fromRow][toCol] = null;
    if (specialMove === 'castling') {
        const rCol = toCol === 6 ? 7 : 0;
        const rToCol = toCol === 6 ? 5 : 3;
        tempBoard[fromRow][rToCol] = tempBoard[fromRow][rCol];
        tempBoard[fromRow][rCol] = null;
    }
    checkPromotionInternal(toRow, toCol, piece, tempBoard);

    // 2. ë¬´ìŠ¹ë¶€ ì¡°ê±´ ê²€ì‚¬
    
    // (A) 50ìˆ˜ ê·œì¹™ ì²´í¬
    const isPawnMove = piece.toUpperCase() === 'P';
    const isCapture = internalBoardState[toRow][toCol] !== null || specialMove === 'enPassant';
    if (gameState.halfMoveClock >= 99 && !isPawnMove && !isCapture) return true;

    // (B) 3íšŒ ë°˜ë³µ ì²´í¬ (Zobrist Hash)
    const nextTurn = currentTurn === 'white' ? 'black' : 'white';
    const nextHash = computeZobristHash(tempBoard, nextTurn);
    if ((positionHistory.get(nextHash) || 0) >= 2) return true;

    // (C) ìŠ¤í…Œì¼ë©”ì´íŠ¸ ì²´í¬
    // ë‚´ ì´ë™ í›„ì— ìƒëŒ€ë°©ì´ ë‘˜ ìˆ˜ ìˆëŠ” í•©ë²•ìˆ˜ê°€ ì—†ëŠ”ì§€ í™•ì¸
    const nextLegalMoves = getLegalMoves(tempBoard, nextTurn);
    if (nextLegalMoves.length === 0 && !isInCheck(nextTurn, tempBoard)) return true;

    return false;
};

const highlightValidMoves = (piece, row, col) => {
    clearHighlightedMoves();
    const boardState = internalBoardState;
    const moves = getValidMoves(piece, row, col, boardState);

    moves.forEach(([r, c, special]) => {
        const cell = getCell(r, c);
        if (cell) {
            // ê¸°ë³¸ í•˜ì´ë¼ì´íŠ¸ í´ë˜ìŠ¤
            cell.classList.add('highlight');
            
            // [ì¶”ê°€] ë¬´ìŠ¹ë¶€ ê²½ê³  ê¸°ëŠ¥ì´ ì¼œì ¸ ìˆë‹¤ë©´ ì²´í¬
            if (showDrawWarnings) {
                const isDrawMove = checkIfMoveleadsToDraw(row, col, r, c, piece, special);
                if (isDrawMove) {
                    cell.classList.add('highlight-draw'); // ì£¼í™©ìƒ‰ ë“±ìœ¼ë¡œ í‘œì‹œ
                }
            }
            
            highlightedCells.push(cell);
        }
    });
};


const clearHighlightedMoves = () => {
    highlightedCells.forEach(cell => {
        cell.classList.remove('highlight');
        cell.classList.remove('highlight-draw');
    });
    highlightedCells = [];
};


const handleCellClick = (cell) => {
    if (gameOver || currentTurn === aiColor) return; // í”Œë ˆì´ì–´ í„´ì´ ì•„ë‹ˆë©´ ë¬´ì‹œ
  
    if (gameMode === 'ai' && currentTurn === aiColor) return;

    if (selectedStorageCell) {
         clearStorageSelection();
        return;
    }

    const targetPieceElement = cell.firstChild;
    const targetPiece = targetPieceElement ? targetPieceElement.dataset.piece : null;
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);

    if (selectedCell) {
        const fromRow = parseInt(selectedCell.dataset.row);
        const fromCol = parseInt(selectedCell.dataset.col);
        const pieceElement = selectedCell.firstChild;
        const piece = pieceElement ? pieceElement.dataset.piece : null;

        if (!piece) {
            console.error('handleCellClick: No piece in selectedCell');
            clearSelection();
            clearHighlightedMoves();
            return;
        }

        const color = piece === piece.toUpperCase() ? 'white' : 'black';
        if (color !== currentTurn) {
             clearSelection();
             clearHighlightedMoves();
             return;
         }

        // Find the target move among highlighted (legal) moves
        const targetMove = highlightedCells.find(highlightedCell =>
            parseInt(highlightedCell.dataset.row) === row && parseInt(highlightedCell.dataset.col) === col
        );


         if (targetMove) { // targetMove is the cell div itself
            const allValidMoves = getValidMoves(piece, fromRow, fromCol, internalBoardState);
            const specificMove = allValidMoves.find(([r, c, _]) => r === row && c === col);

             if (specificMove) {
                 movePiece(cell, specificMove[2]); // Pass the special flag ('enPassant' or 'castling')
             } else {
                  console.warn("Clicked highlighted cell is not a valid move on re-check.");
                  clearSelection();
                  clearHighlightedMoves();
             }

        } else if (cell === selectedCell) {
            // Clicked the same selected cell again - deselect
            clearSelection();
            clearHighlightedMoves();
        } else {
             // Clicked an invalid square or own piece
             const clickedPiece = getPieceAt(row, col, internalBoardState);
             if (clickedPiece && (clickedPiece === clickedPiece.toUpperCase()) === (piece === piece.toUpperCase())) {
                 // Clicked another piece of the same color - switch selection
                 clearSelection();
                 clearHighlightedMoves();
                 selectPiece(cell);
                 highlightValidMoves(clickedPiece, row, col);
             } else {
                 // Clicked an empty invalid square or opponent piece without it being a valid move
                 clearSelection();
                 clearHighlightedMoves();
             }
         }

    } else if (targetPiece) {
         const pieceColor = targetPiece === targetPiece.toUpperCase() ? 'white' : 'black';
         // Select piece only if it's the current player's turn and the piece matches the turn color
         if (pieceColor === currentTurn) {
            selectPiece(cell);
            highlightValidMoves(targetPiece, row, col);
        }
    }
};

// í´ë¦­ í•¸ë“¤ëŸ¬ (ë³´ê´€ì†Œ ì…€ - Not used in standard chess, keep minimal)
const handleStorageCellClick = (cell) => {
    if (gameOver) return;
     console.log("Storage click - not implemented for standard chess rules.");
     clearStorageSelection(); 
};

// ê¸°ë¬¼ ì„ íƒ (ì²´ìŠ¤íŒ)
const selectPiece = (cell) => {
    selectedCell?.classList.remove('selected'); // Deselect previous
    selectedCell = cell;
    cell.classList.add('selected');
};

// ê¸°ë¬¼ ì„ íƒ (ë³´ê´€ì†Œ)
const selectStorageCell = (cell) => {
     selectedStorageCell?.classList.remove('selected');
    selectedStorageCell = cell;
    cell.classList.add('selected');
};


// ê¸°ë¬¼ ì´ë™ (DOM ì—…ë°ì´íŠ¸ ë° ë‚´ë¶€ ìƒíƒœ ì—…ë°ì´íŠ¸ í˜¸ì¶œ)
const movePiece = (targetCell, specialMove = null) => {
    if (!selectedCell || selectedCell === targetCell || !selectedCell.firstChild) {
        clearSelection();
        clearHighlightedMoves();
        return;
    }

    const fromRow = parseInt(selectedCell.dataset.row);
    const fromCol = parseInt(selectedCell.dataset.col);
    const toRow = parseInt(targetCell.dataset.row);
    const toCol = parseInt(targetCell.dataset.col);

    const pieceElement = selectedCell.firstChild;
    const piece = pieceElement.dataset.piece;
    let capturedPieceElement = targetCell.firstChild;
    let capturedPiece = capturedPieceElement ? capturedPieceElement.dataset.piece : null;
    let capturedOnSquare = [toRow, toCol]; // Default capture square
  
    // ì´ë™ ì „ì˜ ë³´ë“œ ìƒíƒœë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì›ë³¸ í•´ì‹œì™€ ë°˜ì „ í•´ì‹œë¥¼ ëª¨ë‘ ìƒì„±
    const phase = getGamePhase(internalBoardState);
    let currentHash = null;
    let currentMirroredHash = null;
  
    let game_depth = 1;

    if (phase === 'endgame') {
         // í˜„ì¬ ë³´ë“œ ìƒíƒœì™€ í„´ì„ ê¸°ì¤€ìœ¼ë¡œ í•´ì‹œ ìƒì„±
        currentHash = computeZobristHash(internalBoardState, currentTurn);
        const mirroredBoard = getMirroredBoard(internalBoardState);
        currentMirroredHash = computeZobristHash(mirroredBoard, currentTurn);
        game_depth = endgame_depth;
    }else{
        game_depth = middlegame_depth;
    }
  
    // --- [ë¬´ìŠ¹ë¶€ ê·œì¹™ ì²´í¬ë¥¼ ìœ„í•œ ì´ˆê¸°í™” íŒë‹¨] ---
    // í°ì´ ì›€ì§ì´ê±°ë‚˜ ê¸°ë¬¼ì„ ì¡ìœ¼ë©´ 50ìˆ˜ ì¹´ìš´í„°ì™€ ë°˜ë³µ ê¸°ë¡ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
  /////ì‚­ì œ///////////////////////
    // if (piece.toUpperCase() === 'P' || capturedPiece || specialMove === 'enPassant') {
    //     gameState.halfMoveClock = 0;
    //     positionHistory.clear(); // ê¸°ë¬¼ êµ¬ì„±ì´ ë°”ë€Œë©´ ì´ì „ê³¼ ë˜‘ê°™ì€ íŒì´ ë‚˜ì˜¬ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ë¹„ì›€
    // } else {
    //     gameState.halfMoveClock++; // ê·¸ ì™¸ì˜ ê²½ìš° ì¹´ìš´íŠ¸ ì¦ê°€
    // }
  //////////////////////////////////
  
     // --- Capture Logic ---
     if (specialMove === 'enPassant') {
         const capturedPawnRow = fromRow; // En passant captures pawn on the 'from' row
         const capturedPawnCol = toCol;
         const capturedPawnCell = getCell(capturedPawnRow, capturedPawnCol);
         if (capturedPawnCell && capturedPawnCell.firstChild) {
             capturedPieceElement = capturedPawnCell.firstChild;
             capturedPiece = capturedPieceElement.dataset.piece;
             capturedOnSquare = [capturedPawnRow, capturedPawnCol]; // Update where capture happened
              // Add captured piece to storage
             addPieceToStorage(capturedPieceElement);
             capturedPawnCell.innerHTML = ''; // Remove from board visually
         } else {
             console.error("En passant error: Cannot find pawn to capture.");
             // Potentially revert or handle error state
         }
     } else if (capturedPieceElement) {
         // Normal capture
         addPieceToStorage(capturedPieceElement);
         targetCell.innerHTML = ''; // Clear target cell before moving piece
     }
  
     

     // --- Handle Castling Rook Move Visually ---
     if (specialMove === 'castling') {
         const rookFromCol = toCol === 6 ? 7 : 0;
         const rookToCol = toCol === 6 ? 5 : 3;
         const rookCell = getCell(fromRow, rookFromCol);
         const rookTargetCell = getCell(toRow, rookToCol);
         if (rookCell && rookCell.firstChild && rookTargetCell) {
             rookTargetCell.appendChild(rookCell.firstChild);
         } else {
              console.error("Castling error: Cannot move rook visually.");
              // Potentially revert or handle error state
          }
     }
  
    // --- Move Piece Logic ---
    targetCell.appendChild(pieceElement); // Move piece visually
    // 1. ë‚´ë¶€ ìƒíƒœë¥¼ ë¨¼ì € ì—…ë°ì´íŠ¸ (ê¸°ë¬¼ì„ ì‹¤ì œë¡œ ì˜®ê¹€)
    //updateInternalBoardState(fromRow, fromCol, toRow, toCol, piece, specialMove);
  
    // [ë³€ê²½] ìˆ˜ë™ ì—…ë°ì´íŠ¸ ëŒ€ì‹  makeMove ì‹œìŠ¤í…œ í™œìš©
    const moveObj = {
        from: [fromRow, fromCol],
        to: [toRow, toCol, specialMove],
        piece: piece
    };
    
    makeMove(internalBoardState, moveObj); // ë‚´ë¶€ ë°°ì—´ ë° ëª¨ë“  ìƒíƒœ(gameState)ë¥¼ í•œêº¼ë²ˆì— ì—…ë°ì´íŠ¸

    // 2. [ìˆ˜ì •] ì—…ë°ì´íŠ¸ëœ ìƒíƒœ(ì´ë™ í›„)ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•´ì‹œ ê³„ì‚°
    const nextTurnColor = currentTurn === 'white' ? 'black' : 'white';
    const postHash = computeZobristHash(internalBoardState, nextTurnColor);

    ///////////////////////////// 3. 3íšŒ ë°˜ë³µ ê¸°ë¡ì— ì¶”ê°€
    // í° ì´ë™ì´ë‚˜ ê¸°ë¬¼ í¬íš ì‹œ positionHistoryë¥¼ ì´ˆê¸°í™”í•˜ëŠ” ë¡œì§
    // makeMove ì´í›„ gameState.halfMoveClockì´ 0ì´ ë˜ì—ˆë‹¤ë©´ ì¤‘ìš”í•œ ë³€í™”(í°/í¬íš)ê°€ ìˆì—ˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.
    if (gameState.halfMoveClock === 0) {
        positionHistory.clear();
    }
    positionHistory.set(postHash, (positionHistory.get(postHash) || 0) + 1);
  
    let currentStaticScore, currentStaticDetails;
    let currentSearchScore, currentSearchDetails;

    // AIì˜ í„´ì´ê³ , ë¯¸ë¦¬ ê³„ì‚°ëœ ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš°
    if (currentTurn === aiColor && aiPendingStaticEval) {
        currentStaticScore = aiPendingStaticEval.score;
        currentStaticDetails = aiPendingStaticEval.details;
        currentSearchScore = aiPendingSearchScore;     // ì „ì—­ ë³€ìˆ˜ì—ì„œ ê°€ì ¸ì˜´
        currentSearchDetails = aiPendingSearchDetails; // ì „ì—­ ë³€ìˆ˜ì—ì„œ ê°€ì ¸ì˜´
        
        // ë°ì´í„° ì‚¬ìš© í›„ ì´ˆê¸°í™”
        aiPendingStaticEval = null;
        aiPendingSearchScore = null;
        aiPendingSearchDetails = null;
    } else if (gameMode === 'ai') { // [ìˆ˜ì •] AI ëª¨ë“œì¼ ë•Œë§Œ í”Œë ˆì´ì–´ ìˆ˜ ë¶„ì„ ìˆ˜í–‰
    const [sScore, sDetails] = evaluateBoard(internalBoardState);
    currentStaticScore = sScore;
    currentStaticDetails = sDetails;

    const isAiMaximizing = (aiColor === 'black');
    const playerSearchDepth = Math.max(1, game_depth - 1);
    const [searchScore, searchDetails] = alphaBeta(internalBoardState, playerSearchDepth, -Infinity, Infinity, !isAiMaximizing, 0, false, playerSearchDepth);
    currentSearchScore = searchScore;
    currentSearchDetails = searchDetails;
} else {
    // [ì¶”ê°€] PvP ëª¨ë“œì¼ ë•ŒëŠ” ë¬´ê±°ìš´ íƒìƒ‰ì„ ìƒëµí•˜ê³  ìµœì†Œí•œì˜ ì •ë³´ë§Œ ì €ì¥
    currentStaticScore = 0;
    currentStaticDetails = null;
    currentSearchScore = 0;
    currentSearchDetails = null;
}
  //////////////////////////////
  
    // --- Record Move ---
     moveHistory.push({
         from: { row: fromRow, col: fromCol },
         to: { row: toRow, col: toCol },
         pieceMoved: piece,
         capturedPiece: capturedPiece, // Can be null
         specialMove: specialMove, // Can be null, 'enPassant', 'castling'
         phaseAtMove: phase,
        boardHash: currentHash,
        mirroredHash: currentMirroredHash,
       ////////////////////////////////////
        evalScore:  currentSearchScore, // í”Œë ˆì´ì–´ì˜ ìˆ˜ë¥¼ AIì˜ ìˆ˜ì½ê¸°ë¡œ í‰ê°€í•œ ì ìˆ˜
        searchDetails: currentSearchDetails,
        staticScore: currentStaticScore, // Static Score (Student)
        staticDetails: currentStaticDetails, // Features (For Tuning)
        aiColor: currentTurn,
        searchDepth: game_depth
       ////////////////////////////////////
     });

    clearSelection();
    clearHighlightedMoves();

    // ìŠ¹ê¸‰ ìƒí™©ì¸ì§€ í™•ì¸
    if (isPromotionSituation(piece, toRow)) {
        // ìŠ¹ê¸‰ ì²˜ë¦¬ (checkPromotion ë‚´ë¶€ì—ì„œ ìŠ¹ê¸‰ ì™„ë£Œ í›„ switchTurnì„ í˜¸ì¶œí•¨)
        checkPromotion(targetCell); 
    } else {
        // ìŠ¹ê¸‰ì´ ì•„ë‹ˆë©´ ì¦‰ì‹œ í„´ êµì²´
        switchTurn();
    }
};

// Helper to add captured piece to the correct storage
const addPieceToStorage = (pieceElement) => {
    if (!pieceElement) return;
    const piece = pieceElement.dataset.piece;
    const isWhite = piece === piece.toUpperCase();
    const storage = isWhite ? whiteCapturedStorage : blackCapturedStorage;
    const emptyStorageCell = Array.from(storage.querySelectorAll('.storage-cell')).find(cell => !cell.firstChild);
    if (emptyStorageCell) {
        emptyStorageCell.appendChild(pieceElement); // Move the element
    } else {
        console.warn("No empty storage cell found for captured piece:", piece);
        // Piece is effectively removed from the game if storage is full
    }
};


// Check if promotion is happening (for turn switching logic)
const isPromotionPending = (cell) => {
     const pieceElement = cell.firstChild;
     if (!pieceElement) return false;
     const piece = pieceElement.dataset.piece;
     const row = parseInt(cell.dataset.row);
     const isWhitePawn = piece === 'P' && row === 0;
     const isBlackPawn = piece === 'p' && row === 7;
     return isWhitePawn || isBlackPawn;
 };

const switchTurn = () => {
    // í„´ì´ ë°”ë€Œê¸° ì „, ë°©ê¸ˆ ìˆ˜ë¥¼ ë‘” ìƒ‰ìƒì„ ê¸°ì–µí•©ë‹ˆë‹¤.
    const previousColor = currentTurn;

    // í„´ êµì²´ (ê¸°ì¡´ ë¡œì§)
    currentTurn = currentTurn === 'white' ? 'black' : 'white';
    
    // --- [ì¶”ê°€ëœ íƒ€ì´ë¨¸ ì—°ë™ ë¶€ë¶„] ---
    if (gameMode === 'pvp') {
        handleTimerOnTurnSwitch(previousColor);
    }
    
    updateStatus(); 

  /////////////////////////////
    // --- ê²Œì„ ì¢…ë£Œ ì‹œ ì²˜ë¦¬ ---
    if (gameOver) {
        if (isSelfPlayMode) {
            remainingSelfPlayGames--; // í•œ íŒ ì™„ë£Œ
            console.log(`[Self-Play] ëŒ€êµ­ ì¢…ë£Œ. ë‚¨ì€ ëŒ€êµ­: ${remainingSelfPlayGames}íŒ`);

            if (remainingSelfPlayGames > 0) {
                // ì•„ì§ ë‚¨ì€ íŒìˆ˜ê°€ ìˆë‹¤ë©´ 3ì´ˆ í›„ ë‹¤ìŒ ëŒ€êµ­ ì‹œì‘
                setTimeout(() => {
                    if (isSelfPlayMode) resetGame();
                }, 3000);
            } else {
                // ëª¨ë“  íŒ ì™„ë£Œ
                stopSelfPlay();
                console.log("%c[Self-Play] ëª¨ë“  ëª©í‘œ ëŒ€êµ­ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.", "color: #2196F3; font-weight: bold;");
            }
        }
        return;
    }

    // --- [ìˆ˜ì •] ìê°€ ëŒ€êµ­ ëª¨ë“œì¼ ë•Œì˜ ë™ì‘ ---
    if (isSelfPlayMode) {
        triggerNextSelfMove();
    } else if (gameMode === 'ai' && currentTurn === aiColor) {
        setTimeout(aiMove, 100);
    }
  ///////////////////////////
};

// ê²Œì„ ì¢…ë£Œ ì¡°ê±´ í™•ì¸ (ì²´í¬ë©”ì´íŠ¸ ë˜ëŠ” ìŠ¤í…Œì¼ë©”ì´íŠ¸)
const isGameOver = (playerColor, boardState, isSimulation = false) => {
    // 1. í•©ë²•ì ì¸ ìˆ˜ê°€ ìˆëŠ”ì§€ ë¨¼ì € ì²´í¬ (ê¸°ì¡´ ë¡œì§)
    const legalMoves = getLegalMoves(boardState, playerColor);
  
  /////ìˆœì„œ ë³€ê²½/////////
    if (legalMoves.length === 0) {
        if (isInCheck(playerColor, boardState)) {
            return "checkmate";
        } else {
            return "stalemate";
        }
    }
  /////////////
    
    // 2. [50ìˆ˜ ê·œì¹™] 50ìˆ˜(100 í•˜í”„ë¬´ë¸Œ) ë„ë‹¬ ì‹œ ë¬´ìŠ¹ë¶€
    // ì‹œë®¬ë ˆì´ì…˜ ì¤‘ì´ë©´ ë‹¤ìŒ ìˆ˜ì— 100ì´ ë  ê²ƒì´ë¯€ë¡œ 99ë¥¼ ê¸°ì¤€ìœ¼ë¡œ íŒë‹¨
    const halfMoveThreshold = isSimulation ? 99 : 100;
    if (gameState.halfMoveClock >= halfMoveThreshold) {
        console.log("Draw by 50-move rule");
        return "draw_50";
    }

    // 3. [3íšŒ ë°˜ë³µ] í˜„ì¬ ìœ„ì¹˜ê°€ 3ë²ˆ ë°˜ë³µë˜ì—ˆì„ ë•Œ ë¬´ìŠ¹ë¶€
    const currentHash = computeZobristHash(boardState, playerColor);
    const count = positionHistory.get(currentHash) || 0;
    // ì‹œë®¬ë ˆì´ì…˜ ì¤‘ì´ë©´ 2ë²ˆë§Œ ê¸°ë¡ë˜ì–´ ìˆì–´ë„ "ë‹¤ìŒ ìˆ˜ì— 3ë²ˆì§¸ê°€ ë¨"ì„ ì˜ë¯¸
    // ì‹¤ì œ ìƒí™©ì´ë©´ ì´ë¯¸ ê¸°ë¡ëœ í›„ì´ë¯€ë¡œ 3ë²ˆì´ì–´ì•¼ í•¨
    const threshold = isSimulation ? 2 : 3; 
  
    if (count >= threshold) {
        console.log("Draw by 3-fold repetition");
        return "draw_repetition";
    }

    return false;
};


// 2. í”Œë ˆì´ì–´ ì²´í¬ë©”ì´íŠ¸ ì•Œë¦¼ í™•ì¸ ë° ëª…í™•í™”
const updateStatus = () => {
    let statusText = "";
    const gameResult = isGameOver(currentTurn, internalBoardState);

    if (gameResult) {
        gameOver = true;
        let winner = 'draw';
        if (gameResult === "draw_50") statusText = "Draw! (50-move rule)";
        else if (gameResult === "draw_repetition") statusText = "Draw! (3-fold repetition)";
        else if (gameResult === "stalemate") statusText = "Draw! (Stalemate)";
        else if (gameResult === "checkmate") {
            winner = currentTurn === 'white' ? 'Black' : 'White';
            statusText = `Checkmate! ${winner} wins!`;
        }
        if (!resultRecorded) {
            // PvP ëª¨ë“œì—ì„œë„ ê¸°ë¡í•˜ê³  ì‹¶ë‹¤ë©´ if ì¡°ê±´ë¬¸ ì‚­ì œ
            if (gameMode === 'ai') recordGameResult(winner);
            resultRecorded = true;
        }

    } else { // ê²Œì„ ì§„í–‰ ì¤‘
        const checkedPlayer = isInCheck(currentTurn, internalBoardState) ? currentTurn : null;
        if (checkedPlayer) {
            // ì²´í¬ ìƒíƒœì¸ í”Œë ˆì´ì–´ê°€ ì‚¬ëŒì¸ì§€ AIì¸ì§€ êµ¬ë¶„
            const playerPronoun = checkedPlayer === aiColor ? `AI (${aiColor})` : `Player (${checkedPlayer})`;
            statusText = `${playerPronoun} is in check! `;
        }
      if (gameMode === 'ai') {
        if (currentTurn === aiColor) {
            statusText += `AI (${aiColor}) Thinking...`;
        } else {
             const playerColor = aiColor === 'white' ? 'black' : 'white';
            statusText += `Player (${playerColor}) turn.`;
        }
      } else {
            // PvP ëª¨ë“œ í‘œì‹œ
            statusText += `PvP Mode: ${currentTurn.toUpperCase()} turn`;
        }
    }
    statusDisplay.textContent = statusText;
    statusDisplay.style.display = 'block';
};

// í° ìŠ¹ê¸‰ ì²´í¬ (ì‹œê°ì )
const checkPromotion = (cell) => {
    const pieceElement = cell.firstChild;
    if (!pieceElement) return;

    const piece = pieceElement.dataset.piece;
    const row = parseInt(cell.dataset.row);
    const isWhitePawn = piece === 'P' && row === 0;
    const isBlackPawn = piece === 'p' && row === 7;

    if (isWhitePawn || isBlackPawn) {
         // If AI promotes, handle automatically (e.g., always Queen)
         if ((isWhitePawn && aiColor === 'white') || (isBlackPawn && aiColor === 'black')) {
              const promotedPiece = isWhitePawn ? 'Q' : 'q';
              cell.innerHTML = ''; // Clear the pawn
              cell.appendChild(createPiece(promotedPiece)); // Add the queen
              internalBoardState[row][parseInt(cell.dataset.col)] = promotedPiece; // Update internal state
              console.log(`AI promoted pawn to ${promotedPiece}`);
              switchTurn(); // Promotion complete, switch turn
         } else {
             // Player promotion: Open popup
             openPromotionPopup(cell, isWhitePawn ? 'white' : 'black');
         }
    }
};

const openPromotionPopup = (cell, color) => {
    const promotionPieces = color === 'white' ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];

    // Disable board interaction while popup is open
    board.style.pointerEvents = 'none';

    const popup = document.createElement('div');
    popup.classList.add('promotion-popup');
     popup.style.position = 'fixed';      // í™”ë©´ì— ê³ ì •
     popup.style.top = '50%';             // ìœ„ì—ì„œ 50% ìœ„ì¹˜
     popup.style.left = '50%';            // ì™¼ìª½ì—ì„œ 50% ìœ„ì¹˜
     popup.style.transform = 'translate(-50%, -50%)'; // ìê¸° í¬ê¸°ë§Œí¼ ë‹¤ì‹œ ë’¤ë¡œ ë°€ì–´ì„œ ì •í™•íˆ ì¤‘ì•™ ì •ë ¬
     popup.style.border = '2px solid black';
     popup.style.background = 'white';
     popup.style.padding = '10px';
     popup.style.zIndex = '1000';


    const message = document.createElement('p');
    message.textContent = 'Promote pawn to:';
     message.style.margin = '0 0 5px 0';
     message.style.textAlign = 'center';
    popup.appendChild(message);

     const pieceContainer = document.createElement('div');
     pieceContainer.style.display = 'flex';
     pieceContainer.style.gap = '5px';


    promotionPieces.forEach((pieceChar) => {
        const pieceElem = createPiece(pieceChar);
         pieceElem.style.cursor = 'pointer';
         pieceElem.style.border = '1px solid #ccc';
         pieceElem.style.padding = '5px';

        pieceElem.addEventListener('click', () => {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            cell.innerHTML = ''; // Remove the pawn
            cell.appendChild(createPiece(pieceChar)); // Add the chosen piece visually
            internalBoardState[row][col] = pieceChar; // Update internal state

            document.body.removeChild(popup); // Close popup
             board.style.pointerEvents = 'auto'; // Re-enable board interaction

             console.log(`Player promoted pawn to ${pieceChar}`);
             switchTurn(); // Promotion chosen, now switch turn
        });
         pieceContainer.appendChild(pieceElem);
    });

    popup.appendChild(pieceContainer);
    document.body.appendChild(popup);
};

// ì„ íƒ ì´ˆê¸°í™” (ì²´ìŠ¤íŒ)
const clearSelection = () => {
    selectedCell?.classList.remove('selected');
    selectedCell = null;
};

// ì„ íƒ ì´ˆê¸°í™” (ë³´ê´€ì†Œ)
const clearStorageSelection = () => {
    selectedStorageCell?.classList.remove('selected');
    selectedStorageCell = null;
};


const resetGame = () => {
  ////////////////////////
    if (isSelfPlayMode) {
        // ìê°€ ëŒ€êµ­ ì‹œì—ëŠ” í˜„ì¬ í„´ì´ ë¬´ì¡°ê±´ AI ì»¬ëŸ¬ê°€ ë˜ë„ë¡ ì„¤ì •
        aiColor = currentTurn; 
    } else if (gameMode === 'ai') {
        aiColor = aiPlayedBlackLastGame ? 'white' : 'black';
        aiPlayedBlackLastGame = (aiColor === 'black');
    } else {
        // PvP ëª¨ë“œì—ì„œëŠ” aiColorê°€ ì˜í–¥ì„ ì£¼ì§€ ì•Šë„ë¡ ì„¤ì • (ì•ˆì „ì„ ìœ„í•´)
        aiColor = null; 
    }
  //////////////////////

    console.log(`--- New Game ---`);

    // 2. Reset board and state
    gameState.halfMoveClock = 0;
    positionHistory.clear();
    createBoard();
    initPieces();
    initStorageAreas();
    initInternalBoardState(); // Reset internal state based on initPieces setup
    moveHistory = [];
    resultRecorded = false; // ì¶”ê°€: ê¸°ë¡ í”Œë˜ê·¸ ì´ˆê¸°í™”
    clearStorageSelection();
    clearSelection();
    clearHighlightedMoves();
    gameOver = false;
    transpositionTable.clear(); // Clear transposition table
     killerMoves.forEach(level => level.length = 0); // Clear killer moves
     Object.keys(historyTable).forEach(key => delete historyTable[key]); // Clear history table
    resetTimers(); 
  //////////////
    kingPos.white = [7, 4];
    kingPos.black = [0, 4];
    initGameHash();
  ////////////////


    // 3. Set the starting turn
    currentTurn = 'white'; // White always starts

    // 4. Update status and trigger AI if it starts
    updateStatus(); // Set initial status message

    // AI ëª¨ë“œì´ê³  AIê°€ ë°±(White)ì´ë©´ ì´ë™ ì˜ˆì•½
    if (gameMode === 'ai' && currentTurn === aiColor && !gameOver) {
        setTimeout(aiMove, 500);
    }
  
  /////////////////////
    // [ì¶”ê°€] ê²Œì„ ë¦¬ì…‹ í›„ ì²« ìˆ˜ íŠ¸ë¦¬ê±°
    if (isSelfPlayMode) {
        setTimeout(triggerNextSelfMove, 500);
    }
  /////////////////////
};

///////////
const initGameHash = () => {
    let hash = 0n; // BigInt ë¦¬í„°ëŸ´ ì‚¬ìš©
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const piece = internalBoardState[r][c];
            if (piece) {
                hash ^= zobristKeys[r][c][pieceToIndex(piece)];
            }
        }
    }
    if (currentTurn === 'black') hash ^= turnKey;

    if (gameState.castlingRights.whiteKingside)  hash ^= castleKeys[0];
    if (gameState.castlingRights.whiteQueenside) hash ^= castleKeys[1];
    if (gameState.castlingRights.blackKingside)  hash ^= castleKeys[2];
    if (gameState.castlingRights.blackQueenside) hash ^= castleKeys[3];

    if (gameState.enPassantSquare) {
        hash ^= enPassantKeys[gameState.enPassantSquare.col];
    }
    currentBoardHash = hash;
};
///////////

const getGamePhase = (boardState) => {
    let totalMaterial = 0;
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = boardState[row][col];
            if (piece && piece.toUpperCase() !== 'K') { // í‚¹ì„ ì œì™¸í•œ ê¸°ë¬¼ ê°€ì¹˜ í•©ì‚°
                totalMaterial += pieceValues[piece];
            }
        }
    }

    if (totalMaterial < ENDGAME_MATERIAL_THRESHOLD) {
        return 'endgame';
    }
    return 'middlegame';
};

//////////////////////////// ê¸°ë³¸ ê°€ì¤‘ì¹˜ ì„¤ì •
let DEFAULT_EVAL_WEIGHTS = {
    oppDistFromCenter_w : 0.5,
distBetweenKings_w : 0.2,
oppKingMoves_w : 0.1,

    mobility: {
        N: 0.06,  // ë‚˜ì´íŠ¸ëŠ” ì´ë™ ë²”ìœ„ê°€ ì¢ìœ¼ë¯€ë¡œ ì¹¸ë‹¹ ì ìˆ˜ë¥¼ ì•½ê°„ ë†’ê²Œ ì„¤ì •
        B: 0.05,  // ë¹„ìˆì€ ë‚˜ì´íŠ¸ë³´ë‹¤ ì¡°ê¸ˆ ë” ë„“ê²Œ ì›€ì§ì„
        R: 0.03,  // ë£©ì€ í›„ë°˜ì— ì¹¸ìˆ˜ê°€ ë§ì•„ì§€ë¯€ë¡œ ë„ˆë¬´ ë†’ìœ¼ë©´ ê¸°ë¬¼ ì ìˆ˜ë¥¼ ì••ë„í•¨
        Q: 0.01   // í€¸ì€ ì¹¸ìˆ˜ê°€ ë§¤ìš° ë§ìœ¼ë¯€ë¡œ ì•„ì£¼ ë‚®ì€ ê°€ì¤‘ì¹˜ ë¶€ì—¬ (ê³¼ì‰ ê³„ì‚° ë°©ì§€)
    },
pinnedActivity_w:0.25,

doubledPawn_w:0.2,
isolatedPawn_w:0.3,
pawnChain_w:0.15,
backwardPawn_w:0.25,
phalanx_w:0.1,

shieldPawn_w:0.2,
hasLuft_w:0.15,
backrankLuft_w:0.3,
dangerzone_w:0.02,

diagonal_Q_w : 0.5,
diagonal_myPawn_w:0.1,
diagonal_oppPawn_w:0.15,
diagonal_others_w:0.05,
diagonal_empty_w:0.05,

file_Q_w:0.5,
file_open_w:0.4,
file_oppPawn_w:0.25,
file_myPawn_w:0.1,

pawn_innerCenter_w : 0.15,
pawn_outerCenter_w: 0.05,
nb_innerCenter_w:0.08,
nb_outerCenter_w:0.03,
rq_innerCenter_w:0.04,

pair_endgame_w:0.5,
pair_middlegame_w:0.3,
bishopPair_w:0.4,

passedPawnRankBonus: [0.0, 0.2, 0.5, 1.0, 1.8, 2.5, 5.5, 8.0], 

doublecheck_w :2.0,
fork_w:0.5,
hanging_w: 0.8,
exchange_w:0.7,
no_exchage_w:0.15,
overloading_w:0.2,
overloading_Q_w:0.2,

nb_opening_w:0.2,
Q_opening_w:0.6,
castling_w:0.9,
castlingRights_w: 0.3,

pawn_positionbonus_w : 1.0,
  
// DEFAULT_EVAL_WEIGHTS ë‚´ë¶€ì— ì¶”ê°€
scalingParams: {
    pawnEndgameIntensity: 1.2,       // ì—”ë“œê²Œì„ì—ì„œ í° ê°€ì¹˜ ì¦ê°€ìœ¨
    complexityReductionRate: 0.1,    // ìš°ì„¸í•  ë•Œ ê¸°ìˆ ì  ì ìˆ˜(í° êµ¬ì¡° ë“±) ê°ì†Œìœ¨
    globalPositionalWeight: 1.0      // ê¸°ë¬¼ ê°€ì¹˜ ëŒ€ë¹„ í¬ì§€ì…˜ ì ìˆ˜ì˜ ì „ì²´ ë¹„ì¤‘
} 
};

// [2] ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸° ì‹œë„
// ì €ì¥ëœ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ì“°ê³ , ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ì„ ë³µì‚¬í•´ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.
let savedWeights = localStorage.getItem('chess_eval_weights');
let eval_weights = savedWeights ? JSON.parse(savedWeights) : JSON.parse(JSON.stringify(DEFAULT_EVAL_WEIGHTS));

console.log(savedWeights ? "ê¸°ì¡´ í•™ìŠµëœ ê°€ì¤‘ì¹˜ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤." : "ê¸°ë³¸ ê°€ì¤‘ì¹˜ë¡œ ì‹œì‘í•©ë‹ˆë‹¤.");
////////////////////////////

// --- Evaluation Functions (Keep as is, they favor Black with higher scores) ---
const evaluateBoard = (boardState) => {
    const phase = getGamePhase(boardState);
    let totalScore = 0;
    let totalDetails = {}; 

    const mergeDetails = (source, sign) => {
        for (let key in source) {
            if (!totalDetails[key]) {
                totalDetails[key] = { score: 0, feature: 0 };
            }
            totalDetails[key].score += source[key].score * sign;
            totalDetails[key].feature += source[key].feature * sign;
        }
    };

    // --- [A] ê¸°ë³¸ ìƒí™© ì •ë³´ ê³„ì‚° ---
    const [bMat, _] = getMaterialScore(boardState, 'black');
    const [wMat, __] = getMaterialScore(boardState, 'white');
    const totalMaterial = bMat + wMat;
    const materialDiff = bMat - wMat; // í‘ ê¸°ì¤€ ìš°ìœ„ (ì–‘ìˆ˜ë©´ í‘ ìš°ì„¸)
  
    // í‚¹ ìœ„ì¹˜ ë¯¸ë¦¬ ì°¾ê¸°
    const blackKingPos = findKing('black', boardState);
    const whiteKingPos = findKing('white', boardState);
    
    // ê³µê²© ë§µ ë¯¸ë¦¬ ìƒì„± (í•„ìš” ì‹œ)
    const blackMoves = getPossibleMoves(boardState, 'black');
    const whiteMoves = getPossibleMoves(boardState, 'white');
    
    // í•™ìŠµëœ ìŠ¤ì¼€ì¼ íŒŒë¼ë¯¸í„°ë“¤
    const params = eval_weights.scalingParams || { 
        pawnEndgameIntensity: 1.0, 
        complexityReductionRate: 0.05, 
        globalPositionalWeight: 1.0 
    };

    // --- [B] ë™ì  ìŠ¤ì¼€ì¼ ê³„ìˆ˜ ìƒì„± ---
    // 1. ì—”ë“œê²Œì„ ë³´ì • (ë‚¨ì€ ê¸°ë¬¼ì´ ì ì„ìˆ˜ë¡ í°ì˜ ê°€ì¹˜ë¥¼ ë†’ì„)
    const endgameContext = Math.max(0, 1.0 - (totalMaterial / 60)); // ê¸°ë¬¼ì´ 0ì¼ ë•Œ 1.0, 60 ì´ìƒì¼ ë•Œ 0.0
    const pawnScale = 1.0 + (endgameContext * params.pawnEndgameIntensity);

    // 2. ìš°ì„¸ ì‹œ ë‹¨ìˆœí™” ë³´ì • (ê¸°ë¬¼ ì°¨ì´ê°€ í´ìˆ˜ë¡ í¬ì§€ì…˜ ë³µì¡ë„ ì ìˆ˜ë¥¼ ì¤„ì„)
    const advantageContext = Math.abs(materialDiff) / 10; // ê¸°ë¬¼ 10ì  ì°¨ì´ë‹¹ 1ë‹¨ìœ„
    const technicalScale = Math.max(0.1, 1.0 - (advantageContext * params.complexityReductionRate));

    // 3. ì „ì²´ í¬ì§€ì…˜ ê°€ì¤‘ì¹˜
    const globalScale = params.globalPositionalWeight;

    // --- 1. ê¸°ë¬¼ ê°€ì¹˜ (ìŠ¤ì¼€ì¼ë§ ì œì™¸ - ì ˆëŒ€ì  ê¸°ì¤€) ---
    totalScore += (bMat - wMat);

    // --- 2. í° ìœ„ì¹˜ ë³´ë„ˆìŠ¤ (pawnScale ì ìš©) ---
    let bPosVal = 0, wPosVal = 0;
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const piece = boardState[r][c];
            if (piece === 'p') bPosVal += pawnPositionValues[7 - r][c];
            if (piece === 'P') wPosVal += pawnPositionValues[r][c];
        }
    }
    const finalPawnPosWeight = eval_weights.pawn_positionbonus_w * technicalScale * globalScale;
    const bPosScore = bPosVal * finalPawnPosWeight;
    const wPosScore = wPosVal * finalPawnPosWeight;
    totalScore += (bPosScore - wPosScore);

    totalDetails['pawn_positionbonus_w'] = {
        score: bPosScore - wPosScore,
        feature: (bPosVal - wPosVal) * technicalScale * globalScale
    };

    // --- 3. í‘œì¤€ í‰ê°€ í•¨ìˆ˜ë“¤ ìˆœíšŒ (ë™ì  ìŠ¤ì¼€ì¼ ì ìš©) ---
    const evalConfigs = [
        { 
            fn: (state, color) => evaluatePieceActivity(state, color, (color === 'white' ? whiteKingPos : blackKingPos)), 
            scale: globalScale 
        },
        { fn: evaluatePawnStructure,   scale: technicalScale * globalScale, paramKey: 'complexityReductionRate', context: -advantageContext },
        { 
            fn: (state, color) => evaluateKingSafety(state, color, (color === 'white' ? whiteKingPos : blackKingPos)), 
            scale: globalScale 
        },
        { fn: evaluateStrategicLines,  scale: globalScale },
        { fn: evaluateCenterControl,   scale: technicalScale * globalScale, paramKey: 'complexityReductionRate', context: -advantageContext },
        { fn: evaluatePiecePairs,      scale: globalScale },
        { fn: evaluatePassedPawns,     scale: pawnScale * globalScale,      paramKey: 'pawnEndgameIntensity',    context: endgameContext },
        { 
            fn: (state, color) => {
                const myM = (color === 'white' ? whiteMoves : blackMoves);
                const oppM = (color === 'white' ? blackMoves : whiteMoves);
                const myK = (color === 'white' ? whiteKingPos : blackKingPos);
                return evaluateThreats(state, color, totalMaterial, myM, oppM, myK);
            }, 
            scale: globalScale 
        }
    ];

    evalConfigs.forEach(config => {
        const [bScore, bDet] = config.fn(boardState, 'black');
        const [wScore, wDet] = config.fn(boardState, 'white');
        const rawDiff = bScore - wScore;
        const scaledDiff = rawDiff * config.scale;
        
        totalScore += scaledDiff;
        mergeDetails(bDet, 1 * config.scale);
        mergeDetails(wDet, -1 * config.scale);

        // [í•µì‹¬] ìŠ¤ì¼€ì¼ íŒŒë¼ë¯¸í„°(pawnEndgameIntensity ë“±)ì˜ íŠœë‹ì„ ìœ„í•œ ê¸°ì—¬ë„ ê¸°ë¡
        if (config.paramKey) {
            const pKey = `scalingParams_${config.paramKey}`;
            if (!totalDetails[pKey]) totalDetails[pKey] = { score: 0, feature: 0 };
            totalDetails[pKey].score += scaledDiff;
            // Feature = ì›ë³¸ì ìˆ˜ * ìƒí™©ë³€ìˆ˜ (ì´ê²ƒì´ ê°€ì¤‘ì¹˜ì— ê³±í•´ì§€ëŠ” ê³„ìˆ˜ê°€ ë¨)
            // [ì…ì‹¤ë¡  ë¡œì§ ì ìš©]
            const rawFeature = rawDiff * config.context * globalScale;
            
            // ë§Œì•½ ì ìˆ˜(rawDiff)ê°€ 0ì´ë¼ë„ ìƒí™©(context)ì´ ì¡´ì¬í•œë‹¤ë©´, 
            // ì•„ì£¼ ë¯¸ì„¸í•œ ë°©í–¥ì„±(0.0001)ì„ ë¶€ì—¬í•˜ì—¬ íŠœë‹ì´ ë©ˆì¶”ì§€ ì•Šê²Œ í•¨.
            const epsilon = 0.0001;
            let finalFeature = rawFeature;

            if (rawFeature === 0 && config.context !== 0) {
                // ì ìˆ˜ê°€ 0ì´ì–´ë„ ìƒí™©(ì—”ë“œê²Œì„ ë“±)ì´ ì§„í–‰ ì¤‘ì´ë©´ ìƒí™©ì˜ ë°©í–¥ëŒ€ë¡œ epsilon ë¶€ì—¬
                finalFeature = Math.sign(config.context) * epsilon;
            }

            totalDetails[pKey].feature += finalFeature;
        }
    });

    // --- 4. êµ­ë©´ë³„ ì „ìš© í‰ê°€ (ì¤‘ë³µ ì—°ì‚° ì œê±° ë²„ì „) ---
    if (phase === 'endgame') {
        // í‘/ë°± ê°ê° í˜¸ì¶œ ì‹œ ì´ë¯¸ êµ¬í•œ bMat, wMat, blackKingPos, whiteKingPosë¥¼ ë„˜ê²¨ì¤Œ
        const [bEnd, bEndDet] = evaluateEndgameBonus(boardState, 'black', blackKingPos, whiteKingPos, bMat, wMat);
        const [wEnd, wEndDet] = evaluateEndgameBonus(boardState, 'white', whiteKingPos, blackKingPos, wMat, bMat);
        
        const diff = (bEnd - wEnd) * globalScale;
        totalScore += diff;
        mergeDetails(bEndDet, 1 * globalScale);
        mergeDetails(wEndDet, -1 * globalScale);
    } else {
        // OpeningDevelopmentëŠ” ê¸°ë¬¼ ì „ê°œë¥¼ ë³´ë¯€ë¡œ ë³´ë“œ ìƒíƒœë§Œ ë„˜ê²¨ì£¼ë˜, 
        // ë‚˜ì¤‘ì— í€¸ì˜ ìœ„ì¹˜ ë“±ì„ ë¯¸ë¦¬ êµ¬í•œë‹¤ë©´ ì—¬ê¸°ë„ ì¸ìë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        const [bOpen, bOpenDet] = evaluateOpeningDevelopment(boardState, 'black');
        const [wOpen, wOpenDet] = evaluateOpeningDevelopment(boardState, 'white');
        
        const diff = (bOpen - wOpen) * globalScale;
        totalScore += diff;
        mergeDetails(bOpenDet, 1 * globalScale);
        mergeDetails(wOpenDet, -1 * globalScale);
    }

    // [ìµœì¢…] globalPositionalWeight íŠœë‹ìš© ê¸°ë¡
    // (ìµœì¢… ì ìˆ˜ì—ì„œ ê¸°ë¬¼ ê°€ì¹˜ë¥¼ ëº€ ë‚˜ë¨¸ì§€ê°€ ê³§ ì „ì²´ í¬ì§€ì…˜ ì ìˆ˜ì„)
    const totalPositionalScore = totalScore - (bMat - wMat);
    // globalScaleì´ 0ì¼ ê²½ìš° Infinityê°€ ë°œìƒí•˜ëŠ” ê²ƒì„ ë°©ì§€
    const safeGlobalScale = Math.max(0.001, globalScale);

    totalDetails['scalingParams_globalPositionalWeight'] = {
        score: totalPositionalScore,
      // ë¶€í˜¸ë¥¼ ìœ ì§€í•˜ë˜, 0 ê·¼ì²˜ì—ì„œë§Œ ë¶ˆì‘ë‹µ(Dead-zone) ì²˜ë¦¬
        feature: Math.abs(totalPositionalScore)< 0.01 ? 0 :  totalPositionalScore/safeGlobalScale
    };

    return [totalScore, totalDetails];
};

const evaluateEndgameBonus = (boardState, color, myKing, oppKing, myMaterial, oppMaterial) => {
    let totalScore = 0;
    let details = {}; // { ê°€ì¤‘ì¹˜í‚¤: { score: ê¸°ì—¬ì ìˆ˜, feature: ì›ì²œê°’ } }
    
    const isWhite = color === 'white';
    const oppColor = isWhite ? 'black' : 'white';
    
    if (myMaterial > oppMaterial + 2) {
        if (!myKing || !oppKing) return [0, {}];

        // (A) ìƒëŒ€ í‚¹ì„ êµ¬ì„ìœ¼ë¡œ ëª°ê¸°
        const distFromCenterVal = Math.abs(oppKing[0] - 3.5) + Math.abs(oppKing[1] - 3.5);
        const distFromCenterScore = distFromCenterVal * eval_weights.oppDistFromCenter_w;
        
        details['oppDistFromCenter_w'] = {
            score: distFromCenterScore,
            feature: distFromCenterVal
        };
        totalScore += distFromCenterScore;

        // (B) ìš°ë¦¬ í‚¹ê³¼ ìƒëŒ€ í‚¹ì˜ ê±°ë¦¬ ì¢íˆê¸°
        const kingDistVal = 14 - (Math.abs(myKing[0] - oppKing[0]) + Math.abs(myKing[1] - oppKing[1]));
        const kingDistScore = kingDistVal * eval_weights.distBetweenKings_w;
        
        details['distBetweenKings_w'] = {
            score: kingDistScore,
            feature: kingDistVal
        };
        totalScore += kingDistScore;
        
        // (C) ìƒëŒ€ í‚¹ì˜ ì´ë™ì„± ì œí•œ
        const oppKingMovesRaw = getValidMoves_Raw(isWhite ? 'k' : 'K', oppKing[0], oppKing[1], boardState);
        const restrictionVal = 8 - oppKingMovesRaw.length;
        const restrictionScore = restrictionVal * eval_weights.oppKingMoves_w;
        
        details['oppKingMoves_w'] = {
            score: restrictionScore,
            feature: restrictionVal
        };
        totalScore += restrictionScore;
    }
    
    return [totalScore, details];
};

const getMaterialScore = (boardState, color) => {
    let totalScore = 0;
    // ê¸°ë¬¼ ê°€ì¹˜ëŠ” ê³ ì •(Fixed)ì´ë¯€ë¡œ details ê°ì²´ëŠ” ë¹„ì›Œë‘¡ë‹ˆë‹¤.
    let details = {}; 
    
    const isWhite = color === 'white';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = boardState[row][col];
            if (piece) {
                const pieceIsWhite = piece === piece.toUpperCase();
                if (pieceIsWhite === isWhite) {
                    const pUpper = piece.toUpperCase();
                    // pieceValuesì—ì„œ ì •ì˜ëœ ìƒìˆ˜ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©
                    totalScore += pieceValues[pUpper];
                }
            }
        }
    }
    
    // [ì´ì , {}] í˜•íƒœë¡œ ë°˜í™˜í•˜ì—¬ íŠœë‹ ì—”ì§„ì´ ë¬´ì‹œí•˜ê²Œ í•¨
    return [totalScore, details];
};

const evaluatePieceActivity = (boardState, color, kingPos) => {
    let totalActivityScore = 0;
    let details = {
        'mobility_N': { score: 0, feature: 0 },
        'mobility_B': { score: 0, feature: 0 },
        'mobility_R': { score: 0, feature: 0 },
        'mobility_Q': { score: 0, feature: 0 },
        'pinnedActivity_w': { score: 0, feature: 0 }
    };

    const isWhite = color === 'white';

    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = boardState[row][col];
            
            if (piece && (isWhite ? piece === piece.toUpperCase() : piece === piece.toLowerCase())) {
                const pUpper = piece.toUpperCase();
                
                if (eval_weights.mobility.hasOwnProperty(pUpper)) {
                    const weight = eval_weights.mobility[pUpper];
                    const moves = getValidMoves_Raw(piece, row, col, boardState);
                    
                    let baseScore = moves.length * weight;
                    let finalPieceScore = baseScore;

                    // í•€(Pin) ìƒíƒœ í™•ì¸
                    if (isPiecePinned(boardState, row, col, color, kingPos)) {
                        // í•€ì— ê±¸ë¦° ê¸°ë¬¼ì˜ ìµœì¢… ì ìˆ˜ëŠ” ì›ë˜ ì ìˆ˜ * ê°ì‡„ ê°€ì¤‘ì¹˜(0.25 ë“±)
                        finalPieceScore = baseScore * eval_weights.pinnedActivity_w;
                        
                        // [íŠœë‹ í¬ì¸íŠ¸] í•€ ê°€ì¤‘ì¹˜(pinnedActivity_w)ì˜ í•™ìŠµì„ ìœ„í•œ ê¸°ë¡
                        // feature: í•€ì— ê±¸ë¦¬ì§€ ì•Šì•˜ì„ ë•Œ ì–»ì—ˆì„ "ê¸°ë³¸ ì ìˆ˜(baseScore)"
                        // score: í•€ ê°€ì¤‘ì¹˜ê°€ ì ìš©ëœ í›„ "ìµœì¢…ì ìœ¼ë¡œ ë‚¨ì€ ì ìˆ˜"
                        details['pinnedActivity_w'].feature += baseScore;
                        details['pinnedActivity_w'].score += finalPieceScore;
                    } else {
                        // í•€ì— ê±¸ë¦¬ì§€ ì•Šì€ ê²½ìš°, í•´ë‹¹ ê¸°ë¬¼ì˜ ìˆœìˆ˜ í™œë™ì„± ì ìˆ˜ ê¸°ë¡
                        const key = `mobility_${pUpper}`;
                        details[key].feature += moves.length;
                        details[key].score += finalPieceScore;
                    }

                    totalActivityScore += finalPieceScore;
                }
            }
        }
    }
    
    return [totalActivityScore, details];
};

const evaluatePawnStructure = (boardState, color) => {
    let totalScore = 0;
    let details = {
        'doubledPawn_w': { score: 0, feature: 0 },
        'isolatedPawn_w': { score: 0, feature: 0 },
        'pawnChain_w': { score: 0, feature: 0 },
        'backwardPawn_w': { score: 0, feature: 0 },
        'phalanx_w': { score: 0, feature: 0 }
    };

    const isWhite = color === 'white';
    const myPawn = isWhite ? 'P' : 'p';
    const direction = isWhite ? -1 : 1;
    
    // íŒŒì¼ë³„ í° ìœ„ì¹˜ ì €ì¥
    const pawnFiles = Array(8).fill().map(() => []);
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            if (boardState[r][c] === myPawn) pawnFiles[c].push(r);
        }
    }

    for (let col = 0; col < 8; col++) {
        const rows = pawnFiles[col];
        
        // 1. ê²¹ì¹œ í° (Doubled Pawn)
        if (rows.length > 1) {
            const count = rows.length - 1;
            const score = -(count * eval_weights.doubledPawn_w);
            details['doubledPawn_w'].score += score;
            details['doubledPawn_w'].feature += -count;
            totalScore += score;
        }

        for (const row of rows) {
            const leftFile = col > 0 ? pawnFiles[col - 1] : [];
            const rightFile = col < 7 ? pawnFiles[col + 1] : [];
            const neighbors = [...leftFile, ...rightFile];

            // 2. ê³ ë¦½ëœ í° (Isolated Pawn)
            if (neighbors.length === 0) {
                const score = -eval_weights.isolatedPawn_w;
                details['isolatedPawn_w'].score += score;
                details['isolatedPawn_w'].feature += -1;
                totalScore += score;
            } else {
                // 3. í° ì²´ì¸ (Pawn Chain)
                const supportRow = row - direction; 
                const isSupported = (col > 0 && boardState[supportRow]?.[col - 1] === myPawn) ||
                                    (col < 7 && boardState[supportRow]?.[col + 1] === myPawn);
                if (isSupported) {
                    const score = eval_weights.pawnChain_w;
                    details['pawnChain_w'].score += score;
                    details['pawnChain_w'].feature += 1;
                    totalScore += score;
                }

                // 4. í›„ì§„ í° (Backward Pawn)
                const isBackward = neighbors.every(nRow => 
                    isWhite ? nRow < row : nRow > row
                );
                if (isBackward) {
                    const score = -eval_weights.backwardPawn_w;
                    details['backwardPawn_w'].score += score;
                    details['backwardPawn_w'].feature += -1;
                    totalScore += score;
                }
            }

            // 5. íŒ”ë‘í¬ìŠ¤ (Phalanx)
            const startingRow = isWhite ? 6 : 1; 
            const hasPhalanx = (col < 7 && boardState[row][col + 1] === myPawn) || 
                               (col > 0 && boardState[row][col - 1] === myPawn);
            
            if (row !== startingRow && hasPhalanx) {
                const score = eval_weights.phalanx_w;
                details['phalanx_w'].score += score;
                details['phalanx_w'].feature += 1; // íŒ”ë‘í¬ìŠ¤ êµ¬ì¡° 1ê°œ ë°œê²¬
                totalScore += score;
            }
        }
    }

    return [totalScore, details];
};

const evaluateKingSafety = (boardState, color, kingPos) => {
    let totalScore = 0;
    let details = {
        'shieldPawn_w': { score: 0, feature: 0 },
        'hasLuft_w': { score: 0, feature: 0 },
        'backrankLuft_w': { score: 0, feature: 0 },
        'dangerzone_w': { score: 0, feature: 0 }
    };

    const isWhite = color === 'white';
    if (!kingPos) return [0, details];
    const [kr, kc] = kingPos;

    // 1. ìºìŠ¬ë§ êµ¬ì—­(Side) ì‰´ë“œ ë° ìˆ¨êµ¬ë©(Luft) í‰ê°€
    if (kc <= 2 || kc >= 5) {
        const direction = isWhite ? -1 : 1;
        const rank2 = isWhite ? 6 : 1;
        const rank3 = isWhite ? 5 : 2;

        let pawnCount = 0;
        let hasLuft = false;

        for (let dc = -1; dc <= 1; dc++) {
            const col = kc + dc;
            if (col < 0 || col > 7) continue;

            if (boardState[rank2][col]?.toUpperCase() === 'P') {
                pawnCount++;
            } else if (boardState[rank3][col]?.toUpperCase() === 'P') {
                pawnCount++;
                if (col === 0 || col === 7 || col === 1 || col === 6) {
                    hasLuft = true; 
                }
            }
        }

        // (A) ì‰´ë“œ í° ë³´ë„ˆìŠ¤
        const shieldScore = pawnCount * eval_weights.shieldPawn_w;
        details['shieldPawn_w'].score = shieldScore;
        details['shieldPawn_w'].feature = pawnCount;
        totalScore += shieldScore;

        // (B) ë°±ë­í¬ ì•ˆì „ì„± (Luft vs Backrank Penalty)
        if (hasLuft) {
            const luftScore = eval_weights.hasLuft_w;
            details['hasLuft_w'].score = luftScore;
            details['hasLuft_w'].feature = 1;
            totalScore += luftScore;
        } else {
            if (isBackRankVulnerable(boardState, color)) {
                const brPenalty = -eval_weights.backrankLuft_w;
                details['backrankLuft_w'].score = brPenalty;
                details['backrankLuft_w'].feature = -1; // ìœ„í—˜ ìƒí™© 1ê±´ ë°œìƒ
                totalScore += brPenalty;
            }
        }
    }

    // 2. ìœ„í—˜ ì§€ì—­(Danger Zone) ê°ì‹œ
    let attackers = 0;
    for (let r = kr - 2; r <= kr + 2; r++) {
        for (let c = kc - 2; c <= kc + 2; c++) {
            if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                const piece = boardState[r][c];
                if (piece && (isWhite ? piece === piece.toLowerCase() : piece === piece.toUpperCase())) {
                    attackers++;
                    // í€¸ì´ë‚˜ ë£©ì€ ê³µê²© í¬ì¸íŠ¸ ê°€ì¤‘
                    if (piece.toUpperCase() === 'Q' || piece.toUpperCase() === 'R') attackers++;
                }
            }
        }
    }

    // (C) ê³µê²©ì ìˆ˜ì— ë”°ë¥¸ ê°ì  (ì œê³± ë¹„ë¡€)
    if (attackers > 0) {
        const attackerFactor = attackers * attackers;
        const dangerPenalty = -(attackerFactor * eval_weights.dangerzone_w);
        details['dangerzone_w'].score = dangerPenalty;
        details['dangerzone_w'].feature = attackerFactor; // ì œê³±ëœ ê°’ì´ ê³§ ê°€ì¤‘ì¹˜ì˜ ê³„ìˆ˜(feature)ê°€ ë¨
        totalScore += dangerPenalty;
    }

    return [totalScore, details];
};

const isBackRankVulnerable = (boardState, color) => {
    const backRank = (color === 'white') ? 7 : 0;
    let defenders = 0;
    for (let c = 0; c < 8; c++) {
        const p = boardState[backRank][c];
        if (p && (color === 'white' ? p === 'R' || p === 'Q' : p === 'r' || p === 'q')) {
            defenders++;
        }
    }
    return defenders < 1; // ë°±ë­í¬ì— ë£©ì´ë‚˜ í€¸ì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ ì·¨ì•½
};

const evaluateStrategicLines = (boardState, color) => {
    let totalScore = 0;
    let details = {};

    const isWhite = color === 'white';
    const myPawn = isWhite ? 'P' : 'p';
    const oppPawn = isWhite ? 'p' : 'P';

    // details ê°ì²´ ì´ˆê¸°í™” ë¡œì§ (ë³‘í•©ì„ í¸í•˜ê²Œ í•˜ê¸° ìœ„í•¨)
    const mergeDetails = (source) => {
        for (let key in source) {
            if (!details[key]) details[key] = { score: 0, feature: 0 };
            details[key].score += source[key].score;
            details[key].feature += source[key].feature;
        }
    };

    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = boardState[row][col];
            if (!piece || (isWhite ? piece !== piece.toUpperCase() : piece !== piece.toLowerCase())) continue;

            const pUpper = piece.toUpperCase();

            // 1. íŒŒì¼ í‰ê°€
            if (pUpper === 'R' || pUpper === 'Q') {
                const [fScore, fDetails] = evaluateFilePurity(boardState, col, myPawn, oppPawn, pUpper);
                totalScore += fScore;
                mergeDetails(fDetails);
            }

            // 2. ëŒ€ê°ì„  í‰ê°€
            if (pUpper === 'B' || pUpper === 'Q') {
                const [dScore, dDetails] = evaluateDiagonalPurity(boardState, row, col, color, myPawn, oppPawn, pUpper);
                totalScore += dScore;
                mergeDetails(dDetails);
            }
        }
    }
    return [totalScore, details];
};

const evaluateDiagonalPurity = (boardState, row, col, color, myPawn, oppPawn, pieceType) => {
    let diagonalScore = 0;
    let localDetails = {
        'diagonal_myPawn_w': { score: 0, feature: 0 },
        'diagonal_oppPawn_w': { score: 0, feature: 0 },
        'diagonal_others_w': { score: 0, feature: 0 },
        'diagonal_empty_w': { score: 0, feature: 0 },
        'diagonal_Q_w': { score: 0, feature: 0 }
    };

    const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
    // í€¸ì¼ ê²½ìš° ë©€í‹°í”Œë¼ì´ì–´ ì ìš©, ì•„ë‹ˆë©´ 1.0
    const qWeight = (pieceType === 'Q') ? eval_weights.diagonal_Q_w : 1.0;

    for (const [dr, dc] of directions) {
        let r = row + dr;
        let c = col + dc;
        
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const target = boardState[r][c];
            let key = '';
            let val = 0;

            if (target === myPawn) {
                key = 'diagonal_myPawn_w';
                val = -eval_weights.diagonal_myPawn_w;
            } else if (target === oppPawn) {
                key = 'diagonal_oppPawn_w';
                val = eval_weights.diagonal_oppPawn_w;
            } else if (target) {
                key = 'diagonal_others_w';
                val = eval_weights.diagonal_others_w;
            } else {
                key = 'diagonal_empty_w';
                val = eval_weights.diagonal_empty_w;
            }

            if (key) {
                const finalScore = val * qWeight;
                diagonalScore += finalScore;
                
                // ê°€ì¤‘ì¹˜ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ê¸°ë¡
                // featureëŠ” ê°€ì¤‘ì¹˜ì— ê³±í•´ì§€ëŠ” 'ê³„ìˆ˜'ì´ë¯€ë¡œ qWeightë¥¼ ê³±í•´ì¤Œ
                localDetails[key].score += finalScore;
                localDetails[key].feature += (key === 'diagonal_myPawn_w' ? -1 : 1) * qWeight;
            }
            
            if (target) break; // ê¸°ë¬¼ì´ ìˆìœ¼ë©´ í•´ë‹¹ ë°©í–¥ ì¤‘ë‹¨
            r += dr; c += dc;
        }
    }

    // í€¸ì¼ ê²½ìš° í€¸ ê°€ì¤‘ì¹˜(diagonal_Q_w) ìì²´ì— ëŒ€í•œ ê¸°ì—¬ë„ë„ ê¸°ë¡
    if (pieceType === 'Q') {
        const baseScore = qWeight !== 0 ? diagonalScore / qWeight : 0; // í€¸ ê°€ì¤‘ì¹˜ ì ìš© ì „ ì ìˆ˜
        localDetails['diagonal_Q_w'].score = diagonalScore;
        localDetails['diagonal_Q_w'].feature = baseScore;
    }

    return [diagonalScore, localDetails];
};

const evaluateFilePurity = (boardState, col, myPawn, oppPawn, pieceType) => {
    let fileScore = 0;
    let localDetails = {
        'file_open_w': { score: 0, feature: 0 },
        'file_oppPawn_w': { score: 0, feature: 0 },
        'file_myPawn_w': { score: 0, feature: 0 },
        'file_Q_w': { score: 0, feature: 0 }
    };

    let myPawnCount = 0;
    let oppPawnCount = 0;
    for (let r = 0; r < 8; r++) {
        if (boardState[r][col] === myPawn) myPawnCount++;
        if (boardState[r][col] === oppPawn) oppPawnCount++;
    }

    const qWeight = (pieceType === 'Q') ? eval_weights.file_Q_w : 1.0;
    let key = '';
    let val = 0;

    if (myPawnCount === 0 && oppPawnCount === 0) {
        key = 'file_open_w';
        val = eval_weights.file_open_w;
    } else if (myPawnCount === 0 && oppPawnCount > 0) {
        key = 'file_oppPawn_w';
        val = eval_weights.file_oppPawn_w;
    } else if (myPawnCount > 0 && oppPawnCount === 0) {
        key = 'file_myPawn_w';
        val = -eval_weights.file_myPawn_w;
    }

    if (key) {
        fileScore = val * qWeight;
        localDetails[key].score = fileScore;
        localDetails[key].feature = (key === 'file_myPawn_w' ? -1 : 1) * qWeight;

        if (pieceType === 'Q') {
            localDetails['file_Q_w'].score = fileScore;
            localDetails['file_Q_w'].feature = val;
        }
    }

    return [fileScore, localDetails];
};

const evaluateCenterControl = (boardState, color) => {
    let totalScore = 0;
    let details = {
        'pawn_innerCenter_w': { score: 0, feature: 0 },
        'pawn_outerCenter_w': { score: 0, feature: 0 },
        'nb_innerCenter_w': { score: 0, feature: 0 },
        'nb_outerCenter_w': { score: 0, feature: 0 },
        'rq_innerCenter_w': { score: 0, feature: 0 }
    };

    const isWhite = color === 'white';
    
    // ì¤‘ì•™ ì˜ì—­ ì •ì˜
    const innerCenter = [[3, 3], [3, 4], [4, 3], [4, 4]];
    const outerCenter = [
        [2, 2], [2, 3], [2, 4], [2, 5],
        [3, 2], [3, 5], [4, 2], [4, 5],
        [5, 2], [5, 3], [5, 4], [5, 5]
    ];

    // í—¬í¼: íŠ¹ì • ê°€ì¤‘ì¹˜ í•­ëª©ì— ì ìˆ˜ì™€ íšŸìˆ˜ë¥¼ ê¸°ë¡
    const addControl = (key, count = 1) => {
        const weight = eval_weights[key];
        const score = weight * count;
        details[key].score += score;
        details[key].feature += count;
        totalScore += score;
    };

    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = boardState[row][col];
            if (!piece || (isWhite ? piece !== piece.toUpperCase() : piece !== piece.toLowerCase())) continue;

            const pUpper = piece.toUpperCase();
            
            // 1. í°ì˜ ì¤‘ì•™ í†µì œ (ëŒ€ê°ì„  ê³µê²© ë°©í–¥)
            if (pUpper === 'P') {
                const dir = isWhite ? -1 : 1;
                const attackRow = row + dir;
                if (attackRow >= 0 && attackRow < 8) {
                    [col - 1, col + 1].forEach(attackCol => {
                        if (attackCol >= 0 && attackCol < 8) {
                            if (isSquareInCenter(attackRow, attackCol, innerCenter)) {
                                addControl('pawn_innerCenter_w');
                            } else if (isSquareInCenter(attackRow, attackCol, outerCenter)) {
                                addControl('pawn_outerCenter_w');
                            }
                        }
                    });
                }
            } 
            // 2. ë‚˜ì´íŠ¸ì™€ ë¹„ìˆì˜ ì¤‘ì•™ ì••ë°•
            else if (pUpper === 'N' || pUpper === 'B') {
                const moves = getValidMoves_Raw(piece, row, col, boardState);
                for (const [mRow, mCol] of moves) {
                    if (isSquareInCenter(mRow, mCol, innerCenter)) {
                        addControl('nb_innerCenter_w');
                    } else if (isSquareInCenter(mRow, mCol, outerCenter)) {
                        addControl('nb_outerCenter_w');
                    }
                }
            }
            // 3. í€¸ê³¼ ë£¨í¬ì˜ ì¤‘ì•™ ì›ê±°ë¦¬ ì§€ì›
            else if (pUpper === 'R' || pUpper === 'Q') {
                const moves = getValidMoves_Raw(piece, row, col, boardState);
                for (const [mRow, mCol] of moves) {
                    if (isSquareInCenter(mRow, mCol, innerCenter)) {
                        addControl('rq_innerCenter_w');
                    }
                    // RQëŠ” OuterCenter ë³´ë„ˆìŠ¤ëŠ” ìƒëµ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
                }
            }
        }
    }
    return [totalScore, details];
};

const isSquareInCenter = (r, c, centerArray) => {
    return centerArray.some(([cr, cc]) => cr === r && cc === c);
};

const evaluatePiecePairs = (boardState, color) => {
    let totalScore = 0;
    // [í•µì‹¬] details ê°ì²´ë¥¼ ë¯¸ë¦¬ ì •ì˜í•˜ê³  ëª¨ë“  í•­ëª©ì„ 0ìœ¼ë¡œ ì´ˆê¸°í™”
    let details = {
        'bishopPair_w': { score: 0, feature: 0 }
    };
    
    const isWhite = color === 'white';
    let myBishops = 0;

    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const p = boardState[r][c];
            if (p && p.toUpperCase() === 'B') {
                if (isWhite ? p === 'B' : p === 'b') myBishops++;
            }
        }
    }

    // ë¹„ìˆ ìŒì´ ìˆì„ ë•Œë§Œ ê°’ì„ ì—…ë°ì´íŠ¸
    if (myBishops >= 2) {
        totalScore = eval_weights.bishopPair_w;
        details['bishopPair_w'].score = totalScore;
        details['bishopPair_w'].feature = 1;
    }

    // ë¹„ìˆ ìŒì´ ìˆë“  ì—†ë“  í•­ìƒ ë™ì¼í•œ êµ¬ì¡°ì˜ [ì ìˆ˜, details]ë¥¼ ë°˜í™˜
    return [totalScore, details];
};

const evaluatePassedPawns = (boardState, color) => {
    let totalScore = 0;
    let details = {}; // { 'passedPawnRankBonus_5': { score: 2.5, feature: 1 } ... }

    const isWhite = color === 'white';
    const pawn = isWhite ? 'P' : 'p';
    const opponentPawn = isWhite ? 'p' : 'P';
    const direction = isWhite ? -1 : 1;

    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            // í•´ë‹¹ ìƒ‰ê¹”ì˜ í°ì„ ì°¾ìœ¼ë©´
            if (boardState[row][col] === pawn) {
                let isPassed = true;
                
                // ì „ë°© ë° ì¸ì ‘ íŒŒì¼ì— ìƒëŒ€ í°ì´ ìˆëŠ”ì§€ í™•ì¸
                for (let checkRow = row + direction; checkRow >= 0 && checkRow < 8; checkRow += direction) {
                    for (let checkCol = col - 1; checkCol <= col + 1; checkCol++) {
                        if (checkCol < 0 || checkCol > 7) continue;
                        if (boardState[checkRow][checkCol] === opponentPawn) {
                            isPassed = false;
                            break;
                        }
                    }
                    if (!isPassed) break;
                }

                if (isPassed) {
                    // ë­í¬ ê³„ì‚° (WhiteëŠ” 7-row, Blackì€ row)
                    const rankIndex = isWhite ? (7 - row) : row;
                    const weight = eval_weights.passedPawnRankBonus[rankIndex];
                    const key = `passedPawnRankBonus_${rankIndex}`;

                    // ì„¸ë¶€ ì •ë³´ ê¸°ë¡
                    if (!details[key]) {
                        details[key] = { score: 0, feature: 0 };
                    }
                    details[key].score += weight;
                    details[key].feature += 1; // í•´ë‹¹ ë­í¬ì˜ í†µê³¼í•œ í° ê°œìˆ˜
                    
                    totalScore += weight;
                }
            }
        }
    }
    return [totalScore, details];
};

const getDynamicPieceValue = (piece, row, col, totalMaterial) => {
    if (!piece) return [0, {}];

    const pUpper = piece.toUpperCase();
    const isWhite = piece === piece.toUpperCase();
    let details = {}; 
    
    // 1. ê¸°ë¬¼ ê¸°ë³¸ ê°€ì¹˜ (Fixed)
    let totalValue = pieceValues[pUpper];

    // 2. í° ë³´ë„ˆìŠ¤ ê³„ì‚° (ìŠ¤ë¬´ìŠ¤í•œ ì „ì´ ë¡œì§)
    if (pUpper === 'P') {
        // [í•µì‹¬] ì—”ë“œê²Œì„ ì§„í–‰ë„ë¥¼ 0.0(ì´ˆë°˜) ~ 1.0(ì™„ì „í•œ ì—”ë“œê²Œì„)ìœ¼ë¡œ ê³„ì‚°
        // ê¸°ë¬¼ í•©ì´ 60ì  ì´ìƒì´ë©´ 0, 0ì ì— ê°€ê¹Œì›Œì§ˆìˆ˜ë¡ 1.0ì— ìˆ˜ë ´
        const endgameProgress = Math.max(0.0001, Math.min(1, 1.0 - (totalMaterial / 60)));
        
        const rankForBonus = isWhite ? (7 - row) : row;
        const baseBonus = eval_weights.passedPawnRankBonus[rankForBonus];
        
        // ë³´ë„ˆìŠ¤ì— ì§„í–‰ë„ë¥¼ ê³±í•˜ì—¬ ìŠ¤ë¬´ìŠ¤í•˜ê²Œ ì ìš©
        const smoothedBonus = baseBonus * endgameProgress;

        totalValue += smoothedBonus;
        
        // íŠœë‹ ì—”ì§„ì´ ì¸ì‹í•  ìˆ˜ ìˆë„ë¡ ê¸°ë¡
        const key = `passedPawnRankBonus_${rankForBonus}`;
        details[key] = {
            score: smoothedBonus,
            feature: endgameProgress // ê°€ì¤‘ì¹˜ì— ê³±í•´ì§„ 'ìƒí™© ê³„ìˆ˜'ë¥¼ featureë¡œ ì „ë‹¬
        };
    }
    
    return [totalValue, details];
};

const evaluateThreats = (boardState, color, totalMaterial, myMoves, opponentMoves, kingPos) => {
    let totalThreatPenalty = 0;
    let details = {
        'doublecheck_w': { score: 0, feature: 0 },
        'fork_w': { score: 0, feature: 0 },
        'hanging_w': { score: 0, feature: 0 },
        'exchange_w': { score: 0, feature: 0 },
        'no_exchange_w': { score: 0, feature: 0 },
        'overloading_w': { score: 0, feature: 0 },
        'overloading_Q_w': { score: 0, feature: 0 }
    };

    const isWhite = color === 'white';
    const opponentColor = isWhite ? 'black' : 'white';

    const defenderTaskCount = new Map();

    // ì„¸ë¶€ ì •ë³´ë¥¼ ë³‘í•©í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
    const mergeDetails = (source) => {
        if (!source) return;
        for (let key in source) {
            if (!details[key]) details[key] = { score: 0, feature: 0 };
            details[key].score += source[key].score;
            details[key].feature += source[key].feature;
        }
    };

    // 1. ë”ë¸” ì²´í¬ íƒì§€
    if (kingPos) {
        const [kr, kc] = kingPos;
        const kingAttackers = opponentMoves.filter(m => m.to[0] === kr && m.to[1] === kc);
        if (kingAttackers.length >= 2) {
            const weight = eval_weights.doublecheck_w;
            details['doublecheck_w'].score -= weight;
            details['doublecheck_w'].feature -= 1;
            totalThreatPenalty += weight;
        }
    }

    // 2. í¬í¬ íƒì§€
    const attacksByPiece = {};
    opponentMoves.forEach(m => {
        const target = boardState[m.to[0]][m.to[1]];
        if (target && (isWhite ? target === target.toUpperCase() : target === target.toLowerCase())) {
            const attackerKey = `${m.from[0]},${m.from[1]}`;
            if (!attacksByPiece[attackerKey]) attacksByPiece[attackerKey] = [];
            
            const [tVal, tDetails] = getDynamicPieceValue(target, m.to[0], m.to[1], totalMaterial);
            const attackerValue = pieceValues[m.piece.toUpperCase()];
            const isDefended = myMoves.some(mm => mm.to[0] === m.to[0] && mm.to[1] === m.to[1]);
            
            if (attackerValue < tVal || !isDefended) {
                attacksByPiece[attackerKey].push({ r: m.to[0], c: m.to[1], val: tVal, details: tDetails });
            }
        }
    });

    for (const key in attacksByPiece) {
        const targets = attacksByPiece[key];
        if (targets.length >= 2) {
            targets.sort((a, b) => b.val - a.val);
            const secondBestTarget = targets[1];
            const penalty = secondBestTarget.val * eval_weights.fork_w;
            
            details['fork_w'].score -= penalty;
            details['fork_w'].feature -= secondBestTarget.val; // ê¸°ë¬¼ ê°€ì¹˜ê°€ ê³„ìˆ˜ê°€ ë¨
            totalThreatPenalty += penalty;
            mergeDetails(secondBestTarget.details); // í° ë³´ë„ˆìŠ¤ ë“± ì„¸ë¶€ì‚¬í•­ ë³‘í•©
        }
    }

    // 3. Hanging ë° SEE êµí™˜ í‰ê°€
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const piece = boardState[r][c];
            if (!piece || (isWhite ? piece !== piece.toUpperCase() : piece !== piece.toLowerCase())) continue;

            const [pVal, pDetails] = getDynamicPieceValue(piece, r, c, totalMaterial);
            const attackers = opponentMoves.filter(m => m.to[0] === r && m.to[1] === c);
            
            if (attackers.length > 0) {
                const defenders = myMoves.filter(m => 
                    m.to[0] === r && m.to[1] === c && !(m.from[0] === r && m.from[1] === c) &&
                    !isPiecePinned(boardState, m.from[0], m.from[1], color)
                );
              
                defenders.forEach(d => {
                    const dKey = `${d.from[0]},${d.from[1]}`;
                    if (!defenderTaskCount.has(dKey)) defenderTaskCount.set(dKey, []);
                    defenderTaskCount.get(dKey).push({r, c});
                });

                let currentPenalty = 0;
                if (defenders.length === 0) {
                    // Hanging Piece
                    currentPenalty = (pVal * eval_weights.hanging_w) + 0.2;
                    details['hanging_w'].score -= currentPenalty;
                    details['hanging_w'].feature -= pVal;
                } else {
                    // SEE êµí™˜ ì‹œë®¬ë ˆì´ì…˜
                    const attackerVals = attackers.map(a => getSEEValue(a.piece, a.from[0], a.from[1], totalMaterial)[0]).sort((a,b)=>a-b);
                    const defenderVals = defenders.map(d => getSEEValue(d.piece, d.from[0], d.from[1], totalMaterial)[0]).sort((a,b)=>a-b);
                    
                    let score = pVal; 
                    let currentScore = score;
                    for (let i = 0; i < attackerVals.length; i++) {
                        if (i < defenderVals.length) {
                            currentScore -= attackerVals[i];
                            if (currentScore < score) score = currentScore;
                            if (i + 1 < attackerVals.length) {
                                currentScore += defenderVals[i];
                                if (currentScore > score) score = currentScore;
                            }
                        } else break;
                    }

                    if (score > 0) {
                        currentPenalty = (score * eval_weights.exchange_w) + 0.2;
                        details['exchange_w'].score -= currentPenalty;
                        details['exchange_w'].feature -= score;
                    } else {
                        currentPenalty = eval_weights.no_exchange_w;
                        details['no_exchange_w'].score -= currentPenalty;
                        details['no_exchange_w'].feature -= 1;
                    }
                }
                const maxSafe = pVal * 0.9;
                currentPenalty = Math.min(currentPenalty, maxSafe);
                totalThreatPenalty += currentPenalty;
                mergeDetails(pDetails);
            }
        }
    }
  
    // 4. ê³¼ë¶€í•˜ íŒ¨ë„í‹°
    defenderTaskCount.forEach((tasks, piecePos) => {
        if (tasks.length >= 2) {
            let totalTaskValue = 0;
            let maxTaskValue = 0;
            tasks.forEach(pos => {
                const targetPiece = boardState[pos.r][pos.c];
                const [val, tDetails] = getDynamicPieceValue(targetPiece, pos.r, pos.c, totalMaterial);
                totalTaskValue += val;
                if (val > maxTaskValue) maxTaskValue = val;
                mergeDetails(tDetails);
            });

            const overloadVal = totalTaskValue - maxTaskValue;
            let penalty = overloadVal * eval_weights.overloading_w;
            details['overloading_w'].score -= penalty;
            details['overloading_w'].feature -= overloadVal;

            const [dR, dC] = piecePos.split(',').map(Number);
            const defenderPiece = boardState[dR][dC];
            if (defenderPiece.toUpperCase() === 'Q') {
                const qPenalty = eval_weights.overloading_Q_w;
                penalty += qPenalty;
                details['overloading_Q_w'].score -= qPenalty;
                details['overloading_Q_w'].feature -= 1;
            }
            totalThreatPenalty += penalty;
        }
    });

    return [-totalThreatPenalty, details];
};

///////////////
const getSEEValue = (piece, row, col, totalMaterial) => {
    const upper = piece.toUpperCase();
    
    // í‚¹ì€ ë™ì  ê°€ì¹˜ì™€ ìƒê´€ì—†ì´ í•­ìƒ ìµœìš°ì„  ìˆœìœ„ (ë§¤ìš° ë†’ì€ ê°€ìƒ ê°€ì¹˜)
    if (upper === 'K') return 1000; 

    // ë‚˜ë¨¸ì§€ ê¸°ë¬¼ë“¤ì€ ìœ„ì¹˜ì™€ êµ­ë©´ì´ ë°˜ì˜ëœ ë™ì  ê°€ì¹˜ë¥¼ ë°˜í™˜
    return getDynamicPieceValue(piece, row, col, totalMaterial);
};
///////////////

const isPiecePinned = (boardState, r, c, color, kingPos) => {
    if (!kingPos) return false;

    const dr = r - kingPos[0];
    const dc = c - kingPos[1];

    // ìˆ˜ì§, ìˆ˜í‰, ëŒ€ê°ì„  ë¼ì¸ì— ìˆëŠ”ì§€ í™•ì¸
    if (dr === 0 || dc === 0 || Math.abs(dr) === Math.abs(dc)) {
        const stepR = dr === 0 ? 0 : dr / Math.abs(dr);
        const stepC = dc === 0 ? 0 : dc / Math.abs(dc);

        let currR = r + stepR;
        let currC = c + stepC;

        while (currR >= 0 && currR < 8 && currC >= 0 && currC < 8) {
            const p = boardState[currR][currC];
            if (p) {
                const isOpponent = (color === 'white' ? p === p.toLowerCase() : p === p.toUpperCase());
                if (isOpponent) {
                    const up = p.toUpperCase();
                    if (up === 'Q') return true;
                    if ((dr === 0 || dc === 0) && up === 'R') return true;
                    if (Math.abs(dr) === Math.abs(dc) && up === 'B') return true;
                }
                break; 
            }
            currR += stepR;
            currC += stepC;
        }
    }
    return false;
};

////////////
const evaluateOpeningDevelopment = (boardState, color) => {
    let totalScore = 0;
    let details = {
        'nb_opening_w': { score: 0, feature: 0 },
        'Q_opening_w': { score: 0, feature: 0 },
        'castling_w': { score: 0, feature: 0 },
        'castlingRights_w': { score: 0, feature: 0 }
    };

    const isWhite = color === 'white';
    const backRank = isWhite ? 7 : 0;

    // 1. ë‚˜ì´íŠ¸, ë¹„ìˆ ì „ê°œ ì²´í¬
    const piecesAtHome = [
        { r: backRank, c: 1, type: isWhite ? 'N' : 'n' }, // í€¸ì‚¬ì´ë“œ ë‚˜ì´íŠ¸
        { r: backRank, c: 6, type: isWhite ? 'N' : 'n' }, // í‚¹ì‚¬ì´ë“œ ë‚˜ì´íŠ¸
        { r: backRank, c: 2, type: isWhite ? 'B' : 'b' }, // í€¸ì‚¬ì´ë“œ ë¹„ìˆ
        { r: backRank, c: 5, type: isWhite ? 'B' : 'b' }  // í‚¹ì‚¬ì´ë“œ ë¹„ìˆ
    ];

    let developedCount = 0;
    let homeCount = 0;

    piecesAtHome.forEach(p => {
        if (boardState[p.r][p.c] === p.type) {
            homeCount++;
        } else {
            developedCount++;
        }
    });

    if (homeCount > 0) {
        const penalty = -(homeCount * eval_weights.nb_opening_w);
        details['nb_opening_w'].score = penalty;
        details['nb_opening_w'].feature = -homeCount; // ì§‘ì— ë‚¨ì•„ìˆëŠ” ê¸°ë¬¼ ìˆ˜ê°€ ê³„ìˆ˜
        totalScore += penalty;
    }

    // 2. ì¡°ê¸° í€¸ ì „ê°œ ê°ì 
    const queenPos = findPiece(isWhite ? 'Q' : 'q', boardState);
    if (queenPos) {
        if (queenPos[0] !== backRank && developedCount < 2) {
            const penalty = -eval_weights.Q_opening_w;
            details['Q_opening_w'].score = penalty;
            details['Q_opening_w'].feature = -1; // ì¡°ê¸° ì „ê°œ ë°œìƒ ì—¬ë¶€
            totalScore += penalty;
        }
    }

    // 3. ìºìŠ¬ë§ í‰ê°€
    const hasCastled = moveHistory.some(m => 
        m.pieceMoved?.toUpperCase() === 'K' && 
        m.specialMove === 'castling' && 
        ((isWhite && m.pieceMoved === 'K') || (!isWhite && m.pieceMoved === 'k'))
    );

    if (hasCastled) {
        const bonus = eval_weights.castling_w;
        details['castling_w'].score = bonus;
        details['castling_w'].feature = 1; // ìºìŠ¬ë§ ì„±ê³µ ì—¬ë¶€
        totalScore += bonus;
    } else {
        const canCastle = isWhite ? 
            (gameState.castlingRights.whiteKingside || gameState.castlingRights.whiteQueenside) :
            (gameState.castlingRights.blackKingside || gameState.castlingRights.blackQueenside);
        
        if (!canCastle) {
            const penalty = -eval_weights.castlingRights_w;
            details['castlingRights_w'].score = penalty;
            details['castlingRights_w'].feature = -1; // ê¶Œí•œ ìƒì‹¤ ì—¬ë¶€
            totalScore += penalty;
        }
    }

    return [totalScore, details];
};

// ë³´ë“œì—ì„œ íŠ¹ì • ê¸°ë¬¼ ìœ„ì¹˜ ì°¾ëŠ” í—¬í¼
const findPiece = (target, boardState) => {
    for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
            if(boardState[r][c] === target) return [r, c];
        }
    }
    return null;
};
///////////

///////////////
const alphaBeta = (boardState, depth, alpha, beta, maximizingPlayer, ply = 0, isCheck = false, initialDepth) => {

    // 1. í˜„ì¬ í„´ ìƒ‰ìƒ ì •ì˜
    const color = maximizingPlayer ? 'black' : 'white';
    const nextColor = maximizingPlayer ? 'white' : 'black'; // ìƒëŒ€ë°© ìƒ‰ìƒ
  
    // ë§Œì•½ ìµœì´ˆ í˜¸ì¶œ ì‹œ initialDepthë¥¼ ê¹œë¹¡í•˜ê³  ì•ˆ ë³´ëƒˆì„ ê²½ìš°ë¥¼ ëŒ€ë¹„í•œ ì•ˆì „ì¥ì¹˜
    if (initialDepth === undefined) initialDepth = depth;
  
  ///////////////
    const currentHash = currentBoardHash.toString();
  ////////////////
  
    // 1. ì‹¤ì œ ê²Œì„ ê¸°ë¡ì—ì„œ ë°œìƒí•œ íšŸìˆ˜
    const historyCount = positionHistory.get(currentHash) || 0;
    // 2. í˜„ì¬ íƒìƒ‰ ì¤‘ì¸ ìŠ¤íƒ(ê²½ë¡œ)ì—ì„œ ë°œìƒí•œ íšŸìˆ˜
    const stackCount = searchStackHashes.filter(h => h === currentHash).length;

    // í•©ì´ 2ë¼ë©´, 'ì§€ê¸ˆ ì´ ë…¸ë“œì— ë„ì°©í•œ ê²ƒ'ì´ 3ë²ˆì§¸ ë°œìƒì„ì„ ì˜ë¯¸ (3íšŒ ë°˜ë³µ í™•ì •)
    // ë˜ëŠ” íƒìƒ‰ ìŠ¤íƒì— ì´ë¯¸ í•œ ë²ˆì´ë¼ë„ ìˆë‹¤ë©´ (stackCount >= 1), 
    // ì´ëŠ” ë¬´í•œ ë£¨í”„(Cycle)ì— ë¹ ì§„ ê²ƒì´ë¯€ë¡œ íƒìƒ‰ íš¨ìœ¨ì„ ìœ„í•´ ì¦‰ì‹œ ë¬´ìŠ¹ë¶€ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    const isRepetition = (historyCount + stackCount >= 2) || (stackCount >= 1);
    const is50MoveDraw = gameState.halfMoveClock >= 99;

    if (isRepetition || is50MoveDraw) {
        // í˜„ì¬ ìœ ë¦¬í•œ ìƒí™©ì´ë¼ë©´ ë¬´ìŠ¹ë¶€ ì ìˆ˜ì— í˜ë„í‹°ë¥¼ ì£¼ì–´ íšŒí”¼í•˜ê²Œ ë§Œë“¦
        return [handleDrawScore(boardState, maximizingPlayer, ply), {}];
    }

    // alphaBeta í•¨ìˆ˜ ìƒë‹¨ TT ì¡°íšŒ ë¶€ë¶„
if (transpositionTable.has(currentHash)) {
    const entry = transpositionTable.get(currentHash);
    if (entry.depth >= depth) {
        // [ìˆ˜ì •] entry.details ëŒ€ì‹  {}ë¥¼ ë°˜í™˜í•˜ì—¬ ë©”ëª¨ë¦¬ ë° ì—°ì‚° ì ˆì•½
        if (entry.flag === 'exact') return [entry.score, {}];
        if (entry.flag === 'lowerbound' && entry.score >= beta) return [beta, {}];
        if (entry.flag === 'upperbound' && entry.score <= alpha) return [alpha, {}];
    }
}
  
    // --- [ì²´í¬ ì—°ì¥ ë¡œì§] ---
    let extension = 0;
    // initialDepthë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìµœëŒ€ ì—°ì¥ í•œê³„(ë³´í†µ ì‹œì‘ ëìŠ¤ì˜ 2ë°°)ë¥¼ ì„¤ì •
    if (isCheck && ply < initialDepth + 2) { 
        extension = 1;
    }
  //////////////////////////
    
    const legalMoves = getLegalMoves(boardState, color);

    /////////////////// (B) ì²´í¬ë©”ì´íŠ¸ ë° ìŠ¤í…Œì¼ë©”ì´íŠ¸ ì²´í¬
    if (legalMoves.length === 0) {
        if (isInCheck(color, boardState)) {
            const mateScore = maximizingPlayer ? -100000 + ply : 100000 - ply;
            // [ìˆ˜ì •] ìˆ«ì ëŒ€ì‹  ë°°ì—´ ë°˜í™˜
            return [mateScore, {}];
        } else {
            // [ìˆ˜ì •] ìˆ«ì ëŒ€ì‹  ë°°ì—´ ë°˜í™˜
            return [handleDrawScore(boardState, maximizingPlayer, ply), {}];
        }
    }
  /////////////////////////

    // --- [í‰ê°€ ë° ì •ì§€ ì¡°ê±´] ---
    if (depth <= 0 && extension === 0) {
        const result = (MAX_QS_DEPTH === 0) 
            ? evaluateBoard(boardState) 
            : quiescenceSearch(boardState, alpha, beta, maximizingPlayer);
        return [result[0], JSON.parse(JSON.stringify(result[1]))];
    }
  
    searchStackHashes.push(currentHash);

    // 5. ìˆ˜ ì •ë ¬ (ì„±ëŠ¥ ìµœì í™”ì˜ í•µì‹¬)
    const sortedMoves = sortMoves(legalMoves, boardState, ply);

  ////////////////////
    let bestDetails = {};
    let foundMove = false; // [ì¶”ê°€] ì²« ë²ˆì§¸ ì´ë™ í™•ì¸ìš©
  //////////////////////
    let bestScore = maximizingPlayer ? -Infinity : Infinity;
    let tt_flag = 'upperbound';

  ///////////////////////
    for (const move of sortedMoves) {
        try {
            // 1. ì´ë™ ì‹¤í–‰ (ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘)
            makeMove(boardState, move); 
          
            const nextIsCheck = isInCheck(nextColor, boardState);

            // 2. ì¬ê·€ í˜¸ì¶œ
            const [score, details] = alphaBeta(boardState, depth - 1 + extension, alpha, beta, !maximizingPlayer, ply + 1, nextIsCheck, initialDepth);

            // 3. ìµœì„ ì˜ ì ìˆ˜ ì—…ë°ì´íŠ¸ (FoundMove ë¡œì§ í¬í•¨)
            if (maximizingPlayer) {
                if (!foundMove || score > bestScore) {
                    bestScore = score;
                    bestDetails = details;
                    tt_flag = 'exact';
                    foundMove = true;
                }
                alpha = Math.max(alpha, bestScore);
            } else {
                if (!foundMove || score < bestScore) {
                    bestScore = score;
                    bestDetails = details;
                    tt_flag = 'exact';
                    foundMove = true;
                }
                beta = Math.min(beta, bestScore);
            }
        } finally { 
            // 4. [í•µì‹¬] ì–´ë–¤ ê²½ìš°ì—ë„ ë°˜ë“œì‹œ ë³´ë“œ ë³µêµ¬ (Unmake)
            unmakeMove(boardState, move);
        }
      //////////////////////////////

        if (beta <= alpha) {
            // í‚¬ëŸ¬ ë¬´ë¸Œ ë° íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸ (ê¸°ì¡´ ë¡œì§)
            recordKillerMove(move, ply, depth, boardState);
            tt_flag = maximizingPlayer ? 'lowerbound' : 'upperbound';
            break;
        }
    }
    searchStackHashes.pop();

    ////////////////////////// ê²°ê³¼ ì €ì¥
    transpositionTable.set(currentHash, { depth, score: bestScore, details: {}, flag: tt_flag });

    return [bestScore, bestDetails];
  /////////////////////
};

//////////////////
// ì˜¤ì§ ê¸°ë¬¼ ì¡ê¸°(Capture)ë§Œ ì¶”ì¶œí•˜ëŠ” í•¨ìˆ˜
const getCaptureMoves = (boardState, color) => {
    const allMoves = getLegalMoves(boardState, color);
    // ëª©ì ì§€ì— ê¸°ë¬¼ì´ ìˆëŠ” ê²½ìš°(Capture)ë§Œ í•„í„°ë§
    return allMoves.filter(move => {
        const [toRow, toCol] = move.to;
        return boardState[toRow][toCol] !== null; 
    });
};

// QS ì „ìš© ê¸°ë¬¼ ì¡ê¸° ì ìˆ˜ ì‚°ì¶œ (MVV-LVA)
const getMvvLvaScore = (move, boardState) => {
    const [toRow, toCol, special] = move.to;
    let targetPiece = boardState[toRow][toCol];

    // [ì¶”ê°€] ì•™íŒŒìƒì¸ ê²½ìš° ëª©ì ì§€ëŠ” nullì´ì§€ë§Œ ì‹¤ì œë¡œëŠ” í°ì„ ì¡ëŠ” ê²ƒì„
    if (!targetPiece && special === 'enPassant') {
        targetPiece = (move.piece === move.piece.toUpperCase()) ? 'p' : 'P';
    }

    if (!targetPiece) return 0;

    const victimValue = pieceValues[targetPiece.toUpperCase()];
    const aggressorValue = pieceValues[move.piece.toUpperCase()];

    return (victimValue * 10) - aggressorValue;
};

const MAX_QS_DEPTH = 2; // ì €ì‚¬ì–‘ PC ê¶Œì¥: 2~4

const quiescenceSearch = (boardState, alpha, beta, maximizingPlayer, qsDepth = 0) => {
    // evaluateBoardëŠ” [ì ìˆ˜, ë°ì´í„°]ë¥¼ ë°˜í™˜í•˜ë¯€ë¡œ ê·¸ëŒ€ë¡œ ì‚¬ìš©
    const [standPat, standPatDetails] = evaluateBoard(boardState);

    if (maximizingPlayer) {
        if (standPat >= beta) return [beta, standPatDetails]; // ë°°ì—´ ë°˜í™˜
        if (alpha < standPat) alpha = standPat;
    } else {
        if (standPat <= alpha) return [alpha, standPatDetails]; // ë°°ì—´ ë°˜í™˜
        if (beta > standPat) beta = standPat;
    }

    if (qsDepth >= MAX_QS_DEPTH) return [standPat, standPatDetails];

    const color = maximizingPlayer ? 'black' : 'white';
    // [ìˆ˜ì •] ëª©ì ì§€ì— ê¸°ë¬¼ì´ ìˆê±°ë‚˜, ì•™íŒŒìƒì¸ ê²½ìš°ë§Œ ìº¡ì²˜ë¡œ ê°„ì£¼
    const captures = getLegalMoves(boardState, color).filter(m => {
        return boardState[m.to[0]][m.to[1]] !== null || m.to[2] === 'enPassant';
    });
    captures.sort((a, b) => getMvvLvaScore(b, boardState) - getMvvLvaScore(a, boardState));

    let bestDetails = standPatDetails;

    for (const move of captures) {
        const [toRow, toCol, special] = move.to;
        let victimPiece = boardState[toRow][toCol];
        
        // [í•µì‹¬ ìˆ˜ì •] ì•™íŒŒìƒ ì‹œ victimPiece ê°•ì œ ì§€ì • (null ì—ëŸ¬ ë°©ì§€)
        if (!victimPiece && special === 'enPassant') {
            victimPiece = maximizingPlayer ? 'P' : 'p'; // ìƒëŒ€ë°©ì˜ í°
        }
        
        // ì•ˆì „ì¥ì¹˜: ì—¬ì „íˆ victimPieceê°€ ì—†ìœ¼ë©´ ì—ëŸ¬ ë°©ì§€ë¥¼ ìœ„í•´ ìŠ¤í‚µ
        if (!victimPiece) continue;

        const victimValue = pieceValues[victimPiece.toUpperCase()];
        
        // Futility Pruning (ë¸íƒ€ ì»¤íŒ…)
        if (maximizingPlayer && (standPat + victimValue + 2.0 < alpha)) continue; 
        if (!maximizingPlayer && (standPat - victimValue - 2.0 > beta)) continue;

        makeMove(boardState, move);
        const [score, details] = quiescenceSearch(boardState, alpha, beta, !maximizingPlayer, qsDepth + 1);
        unmakeMove(boardState, move);

        if (maximizingPlayer) {
            if (score >= beta) return [beta, details];
            if (score > alpha) {
                alpha = score;
                bestDetails = details;
            }
        } else {
            if (score <= alpha) return [alpha, details];
            if (score < beta) {
                beta = score;
                bestDetails = details;
            }
        }
    }

    return [maximizingPlayer ? alpha : beta, bestDetails];
};
/////////////////

const recordKillerMove = (move, ply, depth, boardState) => {
    const [toRow, toCol] = move.to;
    
    // 1. í‚¬ëŸ¬ ë¬´ë¸Œ ê¸°ë¡: ê¸°ë¬¼ì„ ì¡ëŠ” ìˆ˜ê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ê¸°ë¡
    if (!boardState[toRow][toCol]) {
        if (!killerMoves[ply]) killerMoves[ply] = [];
        // ì´ë¯¸ ëª©ë¡ì— ìˆëŠ”ì§€ í™•ì¸ (ì¤‘ë³µ ë°©ì§€)
        if (!killerMoves[ply].some(m => m.from[0] === move.from[0] && m.from[1] === move.from[1] && m.to[0] === move.to[0] && m.to[1] === move.to[1])) {
            killerMoves[ply].unshift(move); // ê°€ì¥ ìµœê·¼ì˜ ì¢‹ì€ ìˆ˜ë¥¼ ë§¨ ì•ìœ¼ë¡œ
            killerMoves[ply] = killerMoves[ply].slice(0, 2); // ìµœëŒ€ 2ê°œë§Œ ìœ ì§€
        }
    }

    // 2. íˆìŠ¤í† ë¦¬ í…Œì´ë¸” ê¸°ë¡: ê¹Šì´ê°€ ê¹Šì„ìˆ˜ë¡ ë” ë†’ì€ ê°€ì¤‘ì¹˜ ë¶€ì—¬
    const historyKey = `${move.piece}_${toRow}_${toCol}`;
    historyTable[historyKey] = (historyTable[historyKey] || 0) + depth * depth;
};

/////////////////
const handleDrawScore = (boardState, maximizingPlayer, ply) => {
    const phase = getGamePhase(boardState);
    // [ìˆ˜ì •] ë¦¬ìŠ¤íŠ¸ì—ì„œ ì ìˆ˜ë§Œ ì¶”ì¶œ
    const [eval, _] = evaluateBoard(boardState);  // í•­ìƒ í‘ ê¸°ì¤€ (Positive = Black leads)
    
    // 1. í˜„ì¬ êµ­ë©´ì—ì„œ ë¬´ìŠ¹ë¶€ í˜ì˜¤ ì§€ìˆ˜ (Contempt Factor)
    // ë¯¸ë“¤ê²Œì„ì—ì„œëŠ” 0.5ì (í° ë°˜ê°œ) ì •ë„ ì†í•´ë¥¼ ë³´ë”ë¼ë„ ê²Œì„ì„ ê³„ì†í•˜ê²Œ í•¨
    const contempt = (phase === 'middlegame') ? 0.5 : 0.1;

    // 2. í˜„ì¬ ìˆ˜ ì°¨ë¡€ì¸ í”Œë ˆì´ì–´(maximizingPlayer)ê°€ ìœ ë¦¬í•œì§€ íŒë‹¨
    // maximizingPlayer === true -> í‘ì˜ í„´
    // maximizingPlayer === false -> ë°±ì˜ í„´
    let isWinning = false;
    let isLosing = false;

    const winThreshold = (phase === 'middlegame') ? 1.5 : 0.8;
    const lossThreshold = (phase === 'middlegame') ? -2.5 : -1.2;

    if (maximizingPlayer) { // í‘ì˜ í„´
        if (eval > winThreshold) isWinning = true;
        if (eval < lossThreshold) isLosing = true;
    } else { // ë°±ì˜ í„´
        if (eval < -winThreshold) isWinning = true;
        if (eval > -lossThreshold) isLosing = true;
    }

    // 3. ì ìˆ˜ ê²°ì •
    if (isWinning) {
        // ë‚´ê°€ ìœ ë¦¬í•œë° ë¬´ìŠ¹ë¶€ê°€ ëœë‹¤? -> ë‚˜ì—ê²Œ ë§¤ìš° ë‚˜ìœ ì ìˆ˜ ë°˜í™˜
        // í‘(Max)ì´ë©´ ì•„ì£¼ ë‚®ì€ ì ìˆ˜, ë°±(Min)ì´ë©´ ì•„ì£¼ ë†’ì€ ì ìˆ˜
        return maximizingPlayer ? (-5000 + ply) : (5000 - ply);
    }

    if (isLosing) {
        // ë‚´ê°€ ë¶ˆë¦¬í•œë° ë¬´ìŠ¹ë¶€ê°€ ëœë‹¤? -> ë‚˜ì—ê²Œ ë§¤ìš° ì¢‹ì€ ì ìˆ˜ ë°˜í™˜
        return maximizingPlayer ? (5000 - ply) : (-5000 + ply);
    }

    // ë¹„ë“±í•œ ìƒí™©: í˜„ì¬ í„´ì¸ ì‚¬ëŒì—ê²Œ ì•½ê°„ì˜ ê°ì (Contempt)ì„ ì£¼ì–´ ë¬´ìŠ¹ë¶€ íšŒí”¼ ìœ ë„
    return maximizingPlayer ? -contempt : contempt;
};
///////////////

const simulateMove = (boardState, move) => {
    const newBoard = boardState.map(row => [...row]);
    const { from, to, piece } = move;
    const [toRow, toCol, special] = to;

    newBoard[toRow][toCol] = piece;
    newBoard[from[0]][from[1]] = null;

    if (special === 'enPassant') {
        newBoard[from[0]][toCol] = null;
    } else if (special === 'castling') {
        const rookFromCol = toCol === 6 ? 7 : 0;
        const rookToCol = toCol === 6 ? 5 : 3;
        newBoard[from[0]][rookToCol] = newBoard[from[0]][rookFromCol];
        newBoard[from[0]][rookFromCol] = null;
    }
    checkPromotionInternal(toRow, toCol, piece, newBoard);
    return newBoard;
};

// í˜„ì¬ ê²Œì„ì˜ ê¶Œí•œ ìƒíƒœë“¤
let gameState = {
    castlingRights: { 
        whiteKingside: true, whiteQueenside: true, 
        blackKingside: true, blackQueenside: true 
    },
    enPassantSquare: null, // ì•™íŒŒìƒì´ ê°€ëŠ¥í•œ íƒ€ê²Ÿ ì¹¸ (ì˜ˆ: {row: 2, col: 3})
    halfMoveClock: 0
};

///////////////
function makeMove(board, move) {
    const { from, to, piece } = move;
    const [fR, fC] = from;
    const [tR, tC, special] = to;
    const isWhite = piece === piece.toUpperCase();
    const pIdx = pieceToIndex(piece);

    // --- [1] ì´ì „ ìƒíƒœ ë°±ì—… ---
    move.prevHash = currentBoardHash; // í˜„ì¬ í•´ì‹œ ì €ì¥ (unmake ì‹œ ë³µêµ¬ìš©)
    move.prevCastlingRights = JSON.parse(JSON.stringify(gameState.castlingRights));
    move.prevEnPassantSquare = gameState.enPassantSquare;
    move.prevHalfMoveClock = gameState.halfMoveClock;
    move.capturedPiece = board[tR][tC];
    move.prevKingPos = isWhite ? [...kingPos.white] : [...kingPos.black];

    // --- [2] í•´ì‹œ ì—…ë°ì´íŠ¸: ê¸°ë¬¼ ì´ë™ ì‹œì‘ ---
    // 1. ì¶œë°œì§€ì—ì„œ ê¸°ë¬¼ ì œê±° (XOR)
    currentBoardHash ^= zobristKeys[fR][fC][pIdx];

    // 2. ëª©ì ì§€ì— ê¸°ë¬¼ì´ ìˆì—ˆë‹¤ë©´ ì œê±° (Capture í•´ì‹œ)
    if (move.capturedPiece) {
        currentBoardHash ^= zobristKeys[tR][tC][pieceToIndex(move.capturedPiece)];
    }

    // 3. ê¶Œí•œ ë° í„´ í•´ì‹œ ì œê±° (ë³€í•˜ê¸° ì „ì˜ ìƒíƒœë¥¼ XORí•´ì„œ ì§€ì›€)
    if (gameState.castlingRights.whiteKingside)  currentBoardHash ^= castleKeys[0];
    if (gameState.castlingRights.whiteQueenside) currentBoardHash ^= castleKeys[1];
    if (gameState.castlingRights.blackKingside)  currentBoardHash ^= castleKeys[2];
    if (gameState.castlingRights.blackQueenside) currentBoardHash ^= castleKeys[3];
    if (gameState.enPassantSquare) currentBoardHash ^= enPassantKeys[gameState.enPassantSquare.col];

    // --- [3] ê¸°ë¬¼ ì‹¤ì œ ì´ë™ ë° íŠ¹ìˆ˜ ê·œì¹™ ì²˜ë¦¬ ---
    board[fR][fC] = null;
    let finalPiece = piece;

    // ìŠ¹ê¸‰ ì²˜ë¦¬ (í•´ì‹œì—ëŠ” ìŠ¹ê¸‰ëœ ê¸°ë¬¼ì„ ë„£ìŒ)
    if (piece === 'P' && tR === 0) finalPiece = 'Q';
    else if (piece === 'p' && tR === 7) finalPiece = 'q';
    
    board[tR][tC] = finalPiece;
    currentBoardHash ^= zobristKeys[tR][tC][pieceToIndex(finalPiece)]; // ëª©ì ì§€ì— ê¸°ë¬¼ ì¶”ê°€ (XOR)

    // ì•™íŒŒìƒ ìº¡ì²˜ í•´ì‹œ ì²˜ë¦¬
    if (special === 'enPassant') {
        const capPawn = isWhite ? 'p' : 'P';
        currentBoardHash ^= zobristKeys[fR][tC][pieceToIndex(capPawn)]; // ì˜†ì— ìˆëŠ” í° ì œê±°
        board[fR][tC] = null;
    }

    // ìºìŠ¬ë§ ë£¨í¬ ì´ë™ í•´ì‹œ ì²˜ë¦¬
    if (special === 'castling') {
        const isKingside = tC === 6;
        const rCol = isKingside ? 7 : 0;
        const rDestCol = isKingside ? 5 : 3;
        const rook = board[fR][rCol];
        currentBoardHash ^= zobristKeys[fR][rCol][pieceToIndex(rook)];    // ë£¨í¬ ì›ë˜ ìë¦¬ ì œê±°
        currentBoardHash ^= zobristKeys[fR][rDestCol][pieceToIndex(rook)]; // ë£¨í¬ ìƒˆ ìë¦¬ ì¶”ê°€
        board[fR][rDestCol] = board[fR][rCol];
        board[fR][rCol] = null;
    }

    // --- [4] ìƒíƒœ ì—…ë°ì´íŠ¸ (í‚¹ ìœ„ì¹˜, ìºìŠ¬ë§ ê¶Œí•œ, ì•™íŒŒìƒ) ---
    if (piece === 'K') {
        gameState.castlingRights.whiteKingside = false;
        gameState.castlingRights.whiteQueenside = false;
        kingPos.white = [tR, tC];
    } else if (piece === 'k') {
        gameState.castlingRights.blackKingside = false;
        gameState.castlingRights.blackQueenside = false;
        kingPos.black = [tR, tC];
    }
    
    updateCastlingRights(fR, fC);
    updateCastlingRights(tR, tC);

    if (piece.toUpperCase() === 'P' && Math.abs(fR - tR) === 2) {
        gameState.enPassantSquare = { row: (fR + tR) / 2, col: fC };
    } else {
        gameState.enPassantSquare = null;
    }

    // --- [5] ìƒˆë¡œìš´ ê¶Œí•œ ë° í„´ í•´ì‹œ ì¶”ê°€ ---
    if (gameState.castlingRights.whiteKingside)  currentBoardHash ^= castleKeys[0];
    if (gameState.castlingRights.whiteQueenside) currentBoardHash ^= castleKeys[1];
    if (gameState.castlingRights.blackKingside)  currentBoardHash ^= castleKeys[2];
    if (gameState.castlingRights.blackQueenside) currentBoardHash ^= castleKeys[3];
    if (gameState.enPassantSquare) currentBoardHash ^= enPassantKeys[gameState.enPassantSquare.col];

    currentBoardHash ^= turnKey; // í„´ êµì²´

    // 50ìˆ˜ ê·œì¹™
    if (piece.toUpperCase() === 'P' || move.capturedPiece) gameState.halfMoveClock = 0;
    else gameState.halfMoveClock++;
}

function unmakeMove(board, move) {
    const [fR, fC] = move.from;
    const [tR, tC, special] = move.to; // move.to ë°°ì—´ì—ì„œ specialì„ ì •í™•íˆ ì¶”ì¶œ
    const piece = move.piece;
    const capturedPiece = move.capturedPiece;

    // 1. í•´ì‹œ ë³µì›
    currentBoardHash = move.prevHash;

    // 2. ê¸°ë¬¼ ìœ„ì¹˜ ë³µì› (ì´ë™í–ˆë˜ ê¸°ë¬¼ì„ ì›ë˜ ì¶œë°œì§€ë¡œ)
    board[fR][fC] = piece;
    
    // 3. ëª©ì ì§€ì— ìˆë˜ ê¸°ë¬¼(ì¡í˜”ë˜ ê¸°ë¬¼) ë³µì›
    board[tR][tC] = capturedPiece;

    const isWhite = piece === piece.toUpperCase();
    if (piece === 'K') kingPos.white = move.prevKingPos;
    else if (piece === 'k') kingPos.black = move.prevKingPos;

    // 4. ì•™íŒŒìƒ ë³µì› (ì´ì œ specialì´ ì •í™•íˆ ì¡íˆë¯€ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤)
    if (special === 'enPassant') {
        // ì•™íŒŒìƒìœ¼ë¡œ ì¡í˜”ë˜ í°ì€ ëª©ì ì§€ê°€ ì•„ë‹Œ ì˜† ì¹¸(fR, tC)ì— ìˆì—ˆìŠµë‹ˆë‹¤.
        board[fR][tC] = isWhite ? 'p' : 'P';
    }

    // 5. ìºìŠ¬ë§ ë£¨í¬ ë³µì›
    if (special === 'castling') {
        const isKingside = tC === 6;
        const rCol = isKingside ? 7 : 0;
        const rDestCol = isKingside ? 5 : 3;
        board[fR][rCol] = board[fR][rDestCol];
        board[fR][rDestCol] = null;
    }

    // 6. ë‚˜ë¨¸ì§€ ìƒíƒœ ë³µì›
    gameState.castlingRights = move.prevCastlingRights;
    gameState.enPassantSquare = move.prevEnPassantSquare;
    gameState.halfMoveClock = move.prevHalfMoveClock;
}
///////////////

function updateCastlingRights(row, col) {
    if (row === 7 && col === 7) gameState.castlingRights.whiteKingside = false;
    if (row === 7 && col === 0) gameState.castlingRights.whiteQueenside = false;
    if (row === 0 && col === 7) gameState.castlingRights.blackKingside = false;
    if (row === 0 && col === 0) gameState.castlingRights.blackQueenside = false;
}

const aiMove = () => {
  /////////////////////////////////////
    if (gameOver) return;
    if (!isSelfPlayMode && currentTurn !== aiColor) return;
  
    // ë§¤ ìˆ˜ë§ˆë‹¤ TTë¥¼ ë¹„ìš°ë©´ ë©”ëª¨ë¦¬ê°€ í•­ìƒ ê¹¨ë—í•˜ê²Œ ìœ ì§€ë©ë‹ˆë‹¤.
    // ì´ì „ í„´ì˜ ë°ì´í„°ê°€ ì—†ì–´ë„ ì´ë²ˆ í„´ì˜ íƒìƒ‰(ë°˜ë³µì  ì‹¬í™” ë“±)ì—ëŠ” ì§€ì¥ì´ ì—†ìŠµë‹ˆë‹¤.
    transpositionTable.clear();
  ////////////////////////////////////
    if (document.querySelector('.promotion-popup')) return;

    console.log(`AI (${aiColor}) is thinking...`);
    updateStatus(); // AI ìƒê° ì¤‘ ìƒíƒœ í‘œì‹œ
  
    // íƒìƒ‰ ì‹œì‘ ì „ ìŠ¤íƒ ì´ˆê¸°í™”
    searchStackHashes = []; 
  
    // 1. í˜¹ì‹œ ëª¨ë¥¼ í”Œë ˆì´ì–´ ì„ íƒ ìƒíƒœë¥¼ ê°•ì œ ì´ˆê¸°í™”
    clearSelection();
    clearHighlightedMoves();
////////////////////////////////////////////////////////
    let bookSelection = null; // ë¬¸ìì—´ ëŒ€ì‹  ì„ íƒ ì •ë³´ë¥¼ ë‹´ì„ ê°ì²´ ë³€ìˆ˜
    
    // --- [ì˜¤í”„ë‹ ë¶ íƒìƒ‰] ---
    if (useOpeningBook) {
        let candidates = null;
        if (moveHistory.length === 0) {
            candidates = CHESS_OPENING_BOOK["start"];
        } else {
            const moveKeyHistory = moveHistory.map(m => 
                `${m.from.row}${m.from.col}${m.to.row}${m.to.col}`
            ).join(',');

            if (CHESS_OPENING_BOOK[moveKeyHistory]) {
                candidates = CHESS_OPENING_BOOK[moveKeyHistory];
            }
        }
        
        if (candidates) {
            bookSelection = pickWeightedMove(candidates);
        }
    }
  
    // ë¶ì— ì„ íƒëœ ê²°ê³¼ê°€ ìˆìœ¼ë©´ ì‹¤í–‰
    if (bookSelection) {
        const { move: bookMoveStr, weight, totalWeight } = bookSelection;
        
        const fR = parseInt(bookMoveStr[0]);
        const fC = parseInt(bookMoveStr[1]);
        const tR = parseInt(bookMoveStr[2]);
        const tC = parseInt(bookMoveStr[3]);

        const fromCell = getCell(fR, fC);
        const toCell = getCell(tR, tC);

        if (fromCell && toCell && fromCell.firstChild) {
            const piece = fromCell.firstChild.dataset.piece;
            const validMoves = getValidMoves(piece, fR, fC, internalBoardState);
            const legalMove = validMoves.find(m => m[0] === tR && m[1] === tC);

            if (legalMove) {
                // --- [í™•ë¥  ê³„ì‚° ë° ì½˜ì†” ë¡œê·¸ ì¶œë ¥] ---
                const probability = ((weight / totalWeight) * 100).toFixed(1);
                console.log(
                    `%c[Opening] ${bookMoveStr} (${probability}%)`, 
                    "color: #2196F3; font-weight: bold;"
                );
                
                selectedCell = fromCell; 
                fromCell.classList.add('ai-highlight');
                toCell.classList.add('ai-highlight');

                movePiece(toCell, legalMove[2]);

                setTimeout(() => {
                    fromCell.classList.remove('ai-highlight');
                    toCell.classList.remove('ai-highlight');
                }, 800);

                return; 
            } else {
                console.warn(`Opening book has an illegal move: ${bookMoveStr}. Falling back to search.`);
            }
        }
    }
    ///////////////////////////////////////////// --- [ì˜¤í”„ë‹ ë¶ ì¢…ë£Œ] ì´í›„ ê¸°ì¡´ì˜ Alpha-Beta íƒìƒ‰ ë¡œì§ ì‹¤í–‰ ---

    const legalMoves = getLegalMoves(internalBoardState, aiColor);

    if (legalMoves.length === 0) {
        console.log(`AI (${aiColor}) has no legal moves. Game should be over.`);
        if (!gameOver) {
            gameOver = true;
            updateStatus();
        }
        return;
    }
    
    let depth;
    const phase = getGamePhase(internalBoardState);

    const currentHash = computeZobristHash(internalBoardState, aiColor);


    if (phase === 'endgame') {
        depth = endgame_depth;
        console.log(`AI mode: Endgame (depth=${depth})`);
    } else {
        depth = middlegame_depth;
        console.log(`AI mode: Middlegame (depth=${depth})`);
    }

    // --- [ìƒˆë¡œìš´ ìƒìˆ˜: íƒí—˜ í™•ë¥ ] ---
    const EXPLORATION_RATE = 0.0; // 20% í™•ë¥ ë¡œ ìƒˆë¡œìš´ ì‹œë„ë¥¼ í•¨
    const isExploring = (phase === 'endgame') && (Math.random() < EXPLORATION_RATE);
    
    if (isExploring) {
        console.log("%cAI Mode: Exploring (Curiosity Driven)", "color: #ff9800; font-weight: bold;");
    }
  
    let bestMove = null;
    let bestScore;
  
    const isAiMaximizing = (aiColor === 'black');
    bestScore = isAiMaximizing ? -Infinity : Infinity;

    // ì´ë™ë³„ ì ìˆ˜ë¥¼ ì €ì¥í•  ë°°ì—´
    const moveScores = [];

    ////////////////////////////// ëª¨ë“  ê°€ëŠ¥í•œ ì´ë™ í‰ê°€
    for (const move of legalMoves) {
      try{
        makeMove(internalBoardState, move); 

        // íƒìƒ‰ ìˆ˜í–‰ (Teacher)
        let [searchScore, searchDetails] = alphaBeta(internalBoardState, depth - 1, -Infinity, Infinity, !isAiMaximizing, 1, false, depth);

        // 2. í•™ìŠµëœ ê°€ì¤‘ì¹˜ ë°˜ì˜ (ì—”ë“œê²Œì„ì¸ ê²½ìš°ì—ë§Œ)
        if (phase === 'endgame') {
            const moveKey = `${move.from[0]}${move.from[1]}${move.to[0]}${move.to[1]}`;
            const dbEntry = (learningDB[currentHash] && learningDB[currentHash][moveKey]) 
                        ? learningDB[currentHash][moveKey] : null;
        
            // dbEntryê°€ [ê°€ì¤‘ì¹˜, ê¹Šì´] ë°°ì—´ì´ë¯€ë¡œ 0ë²ˆì§¸ ìš”ì†Œ(ê°€ì¤‘ì¹˜)ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
            let weight = dbEntry ? dbEntry[0] : 0; 
            
            if (isExploring) {
                // íƒí—˜ ëª¨ë“œì¼ ë•ŒëŠ” ê°€ì¤‘ì¹˜ë¥¼ ì™„ì „íˆ ë¬´ì‹œí•˜ê±°ë‚˜, 
                // ì˜¤íˆë ¤ ê°€ì¤‘ì¹˜ê°€ ë‚®ì€ ìˆ˜ì— ì•„ì£¼ ë¯¸ì„¸í•œ ë³´ë„ˆìŠ¤ë¥¼ ì£¼ì–´ ìƒˆë¡œìš´ ê²½ë¡œë¥¼ ìœ ë„í•©ë‹ˆë‹¤.
                weight = 0; 
                // ë¯¸ì„¸í•œ ë…¸ì´ì¦ˆë¥¼ ì¶”ê°€í•´ ì™„ì „íˆ ë˜‘ê°™ì€ ì ìˆ˜ë“¤ ì‚¬ì´ì—ì„œ ë¬´ì‘ìœ„ì„±ì„ ë¶€ì—¬
                searchScore += (Math.random() - 0.5) * 0.01; 
            } else {
                // ì´ìš© ëª¨ë“œì¼ ë•ŒëŠ” í•™ìŠµëœ ê°€ì¤‘ì¹˜ë¥¼ ì ê·¹ ë°˜ì˜
                searchScore += isAiMaximizing ? weight : -weight;
            }
        }

        moveScores.push({ 
            move, 
            score: searchScore, 
            searchDetails // ì„œì¹˜ê°€ ì°¾ì•„ë‚¸ "ì •ë‹µ" ì„¸ë¶€ êµ¬ì„± 
        });
      } catch (e) {
        console.error("AI íƒìƒ‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", e);
    } finally {
        unmakeMove(internalBoardState, move); // [í•µì‹¬] ì–´ë–¤ ê²½ìš°ì—ë„ ë°˜ë“œì‹œ ë³µêµ¬
    }
    }
  ////////////////////////////
  
    // --- [ìˆ˜íƒ ì„¹ì…˜ - ìˆ˜ì •ë¨] ---
    let chosenEntry = null; // ìµœì ì˜ 'ê°ì²´'ë¥¼ ë‹´ì„ ë³€ìˆ˜

    if (moveHistory.length < 6 && moveScores.length > 0) {
        // ì˜¤í”„ë‹ ë‹¤ì–‘ì„±: ìƒìœ„ 3ê°œ ì¤‘ ëœë¤
        moveScores.sort((a, b) => isAiMaximizing ? b.score - a.score : a.score - b.score);
        const topCount = Math.min(3, moveScores.length);
        chosenEntry = moveScores[Math.floor(Math.random() * topCount)];
        console.log(`AI Opening Move (Random from Top ${topCount}): ${chosenEntry.move.piece} [${chosenEntry.move.from}] -> [${chosenEntry.move.to}], Score: ${chosenEntry.score.toFixed(2)}`);
    } else if (moveScores.length > 0) {
        // ì¼ë°˜ ìƒí™©: ê°€ì¥ ì ìˆ˜ê°€ ë†’ì€ ê°ì²´ ì„ íƒ
        chosenEntry = moveScores.reduce((prev, curr) => {
            if (!prev) return curr;
            if (isAiMaximizing) return curr.score > prev.score ? curr : prev;
            return curr.score < prev.score ? curr : prev;
        }, null);
      if(chosenEntry){
        console.log(`AI Normal Move: ${chosenEntry.move.piece} [${chosenEntry.move.from}] -> [${chosenEntry.move.to}], Best Score: ${chosenEntry.score.toFixed(2)}`);
      }
    }

    // --- [ì‹¤í–‰ ì„¹ì…˜ - ìˆ˜ì •ë¨] ---
    if (chosenEntry) {
        // ì—¬ê¸°ì„œ í•´ì²´í•˜ë©´ chosenEntryê°€ {move, score, searchDetails}ë¥¼ ë‹¤ ê°€ì§€ê³  ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•©ë‹ˆë‹¤.
        const { move, score, searchDetails } = chosenEntry; 
        
        // 1. ì„ íƒëœ ìˆ˜ì— ëŒ€í•´ì„œë§Œ ë”± í•œ ë²ˆ ì •ì  í‰ê°€ ìˆ˜í–‰
        makeMove(internalBoardState, move);
        const [sScore, sDetails] = evaluateBoard(internalBoardState);
        
        aiPendingStaticEval = { score: sScore, details: sDetails };
        aiPendingSearchScore = score;
        aiPendingSearchDetails = searchDetails;
      
        unmakeMove(internalBoardState, move);

        // 2. ì‹¤ì œ ì´ë™ ìˆ˜í–‰
        const fromCell = getCell(move.from[0], move.from[1]);
        const toCell = getCell(move.to[0], move.to[1]);

        if (fromCell && toCell && fromCell.firstChild) {
            const currentHighlightDuration = isSelfPlayMode ? 100 : 1000;
            fromCell.classList.add('ai-highlight');
            toCell.classList.add('ai-highlight');

            selectedCell = fromCell;
            movePiece(toCell, move.to[2]);

            setTimeout(() => {
                const currentFromCell = getCell(move.from[0], move.from[1]);
                const currentToCell = getCell(move.to[0], move.to[1]);
                if (currentFromCell) currentFromCell.classList.remove('ai-highlight');
                if (currentToCell) currentToCell.classList.remove('ai-highlight');
            }, currentHighlightDuration);
        }
    } else {
        console.error(`AI (${aiColor}) could not determine a move.`);
        switchTurn();
    }
};

/////////////////////////
const CHESS_OPENING_BOOK = {
    // [0,0]=a8, [7,7]=h1 ê¸°ì¤€ ì¢Œí‘œ
    // í˜•ì‹: "íˆìŠ¤í† ë¦¬í‚¤": [ ["ì´ë™ì¢Œí‘œ", ì±„íƒë¥ ], ... ]

    // [ë°±ì˜ ì²« ìˆ˜ í†µê³„]
    "start": [
        ["6444", 50.3], // 1. e4
        ["6343", 31.8], // 1. d4
        ["7655", 7.8],  // 1. Nf3
        ["6242", 7.0],  // 1. c4
        ["6656", 0.7],  // 1. g3
        ["6151", 0.5]   // 1. b3
    ],

    // ==========================================
    // KING'S PAWN (1. e4)
    // ==========================================
    "6444": [
        ["1434", 40.0], // 1... e5
        ["1232", 35.0], // 1... c5 (Sicilian)
        ["1424", 10.0], // 1... e6 (French)
        ["1222", 10.0], // 1... c6 (Caro-Kann)
        ["1333", 5.0]   // 1... d5 (Scandinavian)
    ],

    // --- Ruy Lopez (2. Nf3 Nc6 3. Bb5) ---
    "6444,1434": [["7655", 100]], 
    "6444,1434,7655": [["0122", 80], ["0625", 20]],
    "6444,1434,7655,0122": [
        ["7531", 70.0], // 3. Bb5 (Ruy Lopez)
        ["7542", 25.0], // 3. Bc4 (Italian)
        ["6343", 5.0]   // 3. d4 (Scotch)
    ],
    "6444,1434,7655,0122,7531": [
        ["1020", 85.0], // 3... a6
        ["0625", 15.0]  // 3... Nf6 (Berlin)
    ],

    // --- Sicilian Defense (Najdorf Line) ---
    "6444,1232,7655": [["1323", 90], ["0122", 10]],
    "6444,1232,7655,1323": [["6343", 100]],
    "6444,1232,7655,1323,6343": [["3243", 100]],
    "6444,1232,7655,1323,6343,3243": [["5543", 100]],
    "6444,1232,7655,1323,6343,3243,5543": [["0625", 95], ["1424", 5]],
    "6444,1232,7655,1323,6343,3243,5543,0625": [["7152", 100]],
    "6444,1232,7655,1323,6343,3243,5543,0625,7152": [
        ["1020", 70.0], // 6... a6 (Najdorf)
        ["1626", 20.0], // 6... g6 (Dragon)
        ["1424", 10.0]  // 6... e6 (Scheveningen)
    ],

    // ==========================================
    // QUEEN'S PAWN (1. d4)
    // ==========================================
    "6343": [
        ["0625", 55.0], // 1... Nf6
        ["1333", 40.0], // 1... d5
        ["1424", 5.0]   // 1... e6
    ],

    // --- Queen's Gambit Declined ---
    "6343,1333": [["6242", 95], ["7655", 5]],
    "6343,1333,6242": [
        ["1424", 50.0], // 2... e6 (Declined)
        ["1222", 35.0], // 2... c6 (Slav)
        ["3342", 15.0]  // 2... dxc4 (Accepted)
    ],
    "6343,1333,6242,1424": [["7152", 60], ["7655", 40]],

    // --- King's Indian Defense ---
    "6343,0625,6242": [["1626", 100]],
    "6343,0625,6242,1626": [["7152", 80], ["7655", 20]],
};

/**
 * ê°€ì¤‘ì¹˜ ê¸°ë°˜ìœ¼ë¡œ ìˆ˜ë¥¼ ì„ íƒí•˜ê³  ê´€ë ¨ ì •ë³´ë¥¼ í•¨ê»˜ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
const pickWeightedMove = (candidates) => {
    if (!candidates || candidates.length === 0) return null;

    // 1. ì „ì²´ ê°€ì¤‘ì¹˜ í•©ì‚°
    const totalWeight = candidates.reduce((sum, c) => sum + c[1], 0);
    
    // 2. ë‚œìˆ˜ ìƒì„± ë° ì„ íƒ
    let r = Math.random() * totalWeight;
    for (const [move, weight] of candidates) {
        if (r < weight) {
            return { move, weight, totalWeight }; // ê°ì²´ í˜•íƒœë¡œ ë°˜í™˜
        }
        r -= weight;
    }
    
    return { move: candidates[0][0], weight: candidates[0][1], totalWeight };
};

///////////////////////////////

// --- ğŸ‘‘ Self-Learning DB ì„¤ì • ---
const INITIAL_KNOWLEDGE = {
    /* ì—¬ê¸°ì— ë‚˜ì¤‘ì— ì¶”ì¶œí•œ ë°ì´í„°ë¥¼ ë¶™ì—¬ë„£ìœ¼ì‹œë©´ ë©ë‹ˆë‹¤ */
};

const mergeLearningDB = (base, update) => {
    // 1. ë¹ˆ ê°ì²´ì—ì„œ ì‹œì‘ (ë³µì‚¬ ê³¼ì •ì„ ìƒëµí•˜ì—¬ ì†ë„ í–¥ìƒ)
    const merged = {};

    // 2. ê¸°ì´ˆ ì§€ì‹ ë¨¼ì € ì‚½ì…
    for (const hash in base) {
        merged[hash] = { ...base[hash] };
    }

    // 3. ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë°ì´í„°ë¡œ ë®ì–´ì“°ê¸°
    for (const hash in update) {
        if (!merged[hash]) {
            merged[hash] = { ...update[hash] };
        } else {
            // ì´ë¯¸ ìˆëŠ” êµ­ë©´ì´ë©´ ìˆ˜(moveKey)ë§Œ ë³‘í•©
            Object.assign(merged[hash], update[hash]);
        }
    }
    return merged;
};

// [ì¤‘ìš”] í˜ì´ì§€ ë¡œë“œ ì‹œ ë‹¨ í•œ ë²ˆ ì‹¤í–‰
// ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
const savedData = JSON.parse(localStorage.getItem('chess_learning_endgame_db')) || {};
// INITIAL_KNOWLEDGEì™€ ë¡œì»¬ ë°ì´í„°ë¥¼ í•©ì³ì„œ ë©”ëª¨ë¦¬ì— ë¡œë“œ
let learningDB = mergeLearningDB(INITIAL_KNOWLEDGE, savedData);

console.log(`[DB Load] INITIAL: ${Object.keys(INITIAL_KNOWLEDGE).length}ê°œ êµ­ë©´, Local: ${Object.keys(savedData).length}ê°œ êµ­ë©´ ë³‘í•© ì™„ë£Œ.`);

let isStorageFullAlerted = false; // ì•ŒëŒì´ ì´ë¯¸ ë–´ëŠ”ì§€ í™•ì¸í•˜ëŠ” í”Œë˜ê·¸

const saveLearningDB = () => {
    try {
        const dataString = JSON.stringify(learningDB);
        localStorage.setItem('chess_learning_endgame_db', dataString);
    } catch (e) {
        // ìš©ëŸ‰ ì´ˆê³¼ ì—ëŸ¬ì¸ì§€ í™•ì¸
        if (e.name === 'QuotaExceededError' || 
            e.name === 'NS_ERROR_DOM_QUOTA_REACHED' || 
            e.code === 22) { 
            
            console.error("LocalStorage ìš©ëŸ‰ ì´ˆê³¼ ë°œìƒ!");

            // ì´ë²ˆ ì ‘ì† ì¤‘ì— ì•„ì§ ì•ŒëŒì„ ì•ˆ ë„ì› ë‹¤ë©´ ì•ŒëŒ í‘œì‹œ
            if (!isStorageFullAlerted) {
                alert("âš ï¸ ë¸Œë¼ìš°ì € ì €ì¥ ê³µê°„ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤!\n\nAIì˜ ìƒˆë¡œìš´ í•™ìŠµ ë°ì´í„°ë¥¼ ë” ì´ìƒ ì €ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n'ë°ì´í„° ì¶”ì¶œ' ë²„íŠ¼ì„ ëˆŒëŸ¬ ë°ì´í„°ë¥¼ ë°±ì—…í•œ ë’¤,\nINITIAL_KNOWLEDGEë¥¼ ì—…ë°ì´íŠ¸í•˜ê³  'ë°ì´í„° ì´ˆê¸°í™”'ë¥¼ í•´ì£¼ì„¸ìš”.");
                isStorageFullAlerted = true; // ì¤‘ë³µ ì•ŒëŒ ë°©ì§€
            }
        } else {
            // ë‹¤ë¥¸ ì—ëŸ¬ì¼ ê²½ìš° ì½˜ì†”ì— ê¸°ë¡
            console.error("DB ì €ì¥ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ:", e);
        }
    }
};

const computeZobristHash = (boardState, turn) => {
  ////////////
    let hash = 0n;
  ////////////
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = boardState[row][col];
            if (piece) {
                const index = pieceToIndex(piece);
                if (index !== -1) {
                    hash ^= zobristKeys[row][col][index];
                }
            }
        }
    }
    if (turn === 'black') hash ^= turnKey; // í„´ ì •ë³´ í¬í•¨
  
  /////////////////
    // 3. ì•™íŒŒìƒ ê¶Œí•œ (ì¶”ê°€)
    // ì•™íŒŒìƒ íƒ€ê²Ÿ ì¹¸ì´ ìˆë‹¤ëŠ” ê²ƒì€ ë°©ê¸ˆ í°ì´ 2ì¹¸ ì „ì§„í–ˆìŒì„ ì˜ë¯¸
    if (gameState.enPassantSquare) {
        hash ^= enPassantKeys[gameState.enPassantSquare.col];
    }

    // 4. ìºìŠ¬ë§ ê¶Œí•œ (ì¶”ê°€)
    if (gameState.castlingRights.whiteKingside)  hash ^= castleKeys[0];
    if (gameState.castlingRights.whiteQueenside) hash ^= castleKeys[1];
    if (gameState.castlingRights.blackKingside)  hash ^= castleKeys[2];
    if (gameState.castlingRights.blackQueenside) hash ^= castleKeys[3];
  ////////////////
  
    return hash.toString(); // ê°ì²´ í‚¤ë¡œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ë¬¸ìì—´ ë°˜í™˜
};

const getDBTotalCount = (db) => {
    let count = 0;
    for (const hash in db) {
        // ê° í•´ì‹œ(êµ­ë©´) ì•„ë˜ì— ë§¤í•‘ëœ moveKey(ì´ë™)ë“¤ì˜ ê°œìˆ˜ë¥¼ í•©ì‚°
        count += Object.keys(db[hash]).length;
    }
    return count;
};

/////////////////
function tuneWeights(moveEntry, moveIndex) {
    const teacher = moveEntry.searchDetails; 
    const student = moveEntry.staticDetails; 
    
    if (!teacher || !student || Object.keys(teacher).length === 0) return;

    // ì¼ë°˜ ê°€ì¤‘ì¹˜ì™€ ìŠ¤ì¼€ì¼ë§ íŒŒë¼ë¯¸í„°ì˜ í•™ìŠµ ì†ë„ë¥¼ ë‹¤ë¥´ê²Œ ê°€ì ¸ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    const learningRate = 0.005; 
    const scaleParamStep = 0.001; // ìŠ¤ì¼€ì¼ë§ íŒŒë¼ë¯¸í„°ìš© ê³ ì • ë³´í­ (ì¡°ê¸ˆ ë” ì‹ ì¤‘í•˜ê²Œ)
    
    let changeLog = [];

    for (let key in student) {
        if (!teacher[key]) continue;

        // [1] ì˜¤ì°¨ ê³„ì‚° (Teacher - Student)
        const rawError = teacher[key].score - student[key].score;
        // [ë³´ìˆ˜ì  ì—ëŸ¬ ìº¡í•‘] 
        // ì—ëŸ¬ê°€ ì•„ë¬´ë¦¬ ì»¤ë„ 2.0(í° 2ê°œ) ìˆ˜ì¤€ìœ¼ë¡œ ì œí•œí•˜ì—¬ 'í¬ì§€ì…˜ ì§€ì‹'ì´ íŒŒê´´ë˜ëŠ” ê²ƒì„ ë§‰ìŒ
        const error = Math.max(-2.0, Math.min(2.0, rawError));
        if (Math.abs(error) < 0.0001) continue;

        const featureVal = student[key].feature;
        if (featureVal === 0) continue;

        // --- íŠœë‹ ë¡œì§ ë¶„ê¸° ---

        // [A] ìŠ¤ì¼€ì¼ë§ íŒŒë¼ë¯¸í„° íŠœë‹ (ì—ëŸ¬ ë°©í–¥ * íŠ¹ì§• ë°©í–¥ * ê³ ì • ë³´í­)
        if (key.startsWith('scalingParams_')) {
            const paramName = key.split('_')[1];
            if (eval_weights.scalingParams && eval_weights.scalingParams.hasOwnProperty(paramName)) {
                
                // ì‚¬ìš©ìë‹˜ ìš”ì²­ ë°˜ì˜: ì—ëŸ¬ì™€ íŠ¹ì§• ëª¨ë‘ 'ë¶€í˜¸(ë°©í–¥)'ë§Œ ì·¨í•¨
                const errorDirection = Math.sign(error);
                const featureDirection = Math.sign(featureVal);
                
                // ì—…ë°ì´íŠ¸ëŸ‰ = ì—ëŸ¬ë°©í–¥ * íŠ¹ì§•ë°©í–¥ * ê³ ì •ë³´í­
                let updateAmount = errorDirection * featureDirection * scaleParamStep;
                
                const oldWeight = eval_weights.scalingParams[paramName];
                eval_weights.scalingParams[paramName] += updateAmount;

                // ì•ˆì „ ë²”ìœ„ (0.1 ~ 5.0)
                let minBound = (paramName === 'globalPositionalWeight') ? 0.1 : 0.0;
                eval_weights.scalingParams[paramName] = Math.max(minBound, Math.min(5.0, eval_weights.scalingParams[paramName]));

                if (Math.abs(updateAmount) > 0) {
                    changeLog.push(`[Strategy] ${paramName}: ${oldWeight.toFixed(5)} -> ${eval_weights.scalingParams[paramName].toFixed(5)} (Dir Update)`);
                }
            }
        }
        // [B] ì¼ë°˜ ê°€ì¤‘ì¹˜ íŠœë‹ (ê¸°ì¡´ ë¡œì§ ìœ ì§€: ì—ëŸ¬ í¬ê¸° ë°˜ì˜)
        else {
            const featureDirection = Math.sign(featureVal);
            let updateAmount = error * featureDirection * learningRate;
            let oldWeight = 0;

            if (key.startsWith('mobility_')) {
                const piece = key.split('_')[1];
                oldWeight = eval_weights.mobility[piece];
                eval_weights.mobility[piece] = Math.max(0.001, Math.min(2.0, eval_weights.mobility[piece] + updateAmount));
                if (Math.abs(updateAmount) > 0.00001) changeLog.push(`mobility_${piece}: ${oldWeight.toFixed(5)} -> ${eval_weights.mobility[piece].toFixed(5)}`);
            }
            else if (key.startsWith('passedPawnRankBonus_')) {
                const rank = parseInt(key.split('_')[1]);
                oldWeight = eval_weights.passedPawnRankBonus[rank];
                eval_weights.passedPawnRankBonus[rank] = Math.max(0.0, Math.min(20.0, eval_weights.passedPawnRankBonus[rank] + updateAmount));
                if (Math.abs(updateAmount) > 0.00001) changeLog.push(`passedRank_${rank}: ${oldWeight.toFixed(5)} -> ${eval_weights.passedPawnRankBonus[rank].toFixed(5)}`);
            }
            else if (typeof eval_weights[key] === 'number') {
                oldWeight = eval_weights[key];
                eval_weights[key] += updateAmount;
                eval_weights[key] = Math.max(0.0, Math.min(15.0, eval_weights[key]));
                if (Math.abs(updateAmount) > 0.00001) changeLog.push(`${key}: ${oldWeight.toFixed(5)} -> ${eval_weights[key].toFixed(5)}`);
            }
        }
    }

    if (changeLog.length > 0) {
        console.log(`%c[Fine-Tuning Move ${moveIndex}] %cUpdate Log:`, "color: #ffeb3b; font-weight: bold;", "color: white;");
        changeLog.forEach(log => console.log(`  â”” %c${log}`, "color: #8bc34a;"));
    }
}
////////////////

const recordGameResult = (winner) => {
  ///////////////////////////
    // --- [ì „ì  ê¸°ë¡ ì¶”ê°€] ---
    if (isSelfPlayMode) {
        selfPlayResults.totalCompleted++;
        if (winner === 'White') selfPlayResults.white++;
        else if (winner === 'Black') selfPlayResults.black++;
        else selfPlayResults.draw++;
        
        updateScoreboardUI(); // UI ê°±ì‹ 
    }
  
    // --- [Self-Tuning í”„ë¡œì„¸ìŠ¤] ---
    if (isSelfTuningEnabled) {
        console.log("%c[Tuning] íŒŒì¸ íŠœë‹ í”„ë¡œì„¸ìŠ¤ ì‹œì‘...", "color: #2196f3; font-weight: bold;");
        
        if (moveHistory.length > 0) {
            moveHistory.forEach((move, idx) => tuneWeights(move, idx + 1));
            localStorage.setItem('chess_eval_weights', JSON.stringify(eval_weights));
            console.log("%c[Tuning] ëª¨ë“  ê°€ì¤‘ì¹˜ê°€ ì—…ë°ì´íŠ¸ë˜ê³  ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.", "color: #4caf50; font-weight: bold;");
        } else {
            console.log("[Tuning] ê¸°ë¡ëœ ìˆ˜ìˆœì´ ì—†ì–´ íŠœë‹ì„ ìƒëµí•©ë‹ˆë‹¤.");
        }
    } else {
        console.log("%c[Tuning] Self-Tuning ê¸°ëŠ¥ì´ ë¹„í™œì„±í™” ìƒíƒœì…ë‹ˆë‹¤. (ê°€ì¤‘ì¹˜ ê³ ì •)", "color: #9e9e9e;");
    }
  //////////////////////////
  //ifë¬¸ìœ¼ë¡œ ê°ì‹¸ê¸°/////////////////////
  if (isEndgameDBEnabled) {
    const countBefore = getDBTotalCount(learningDB);
    const endgameMoves = moveHistory.filter(m => m.phaseAtMove === 'endgame' && m.boardHash);
    
    if (endgameMoves.length < 2) {
        console.log("No endgame moves to learn.");
        return;
    }
  
    let blunderCount = 0;
    let brilliantCount = 0;

    const isAiWin = (winner === aiColor);
    const isDraw = (winner === 'draw');

    console.log(`[Learning] Processing ${endgameMoves.length} endgame moves...`);

    // ê°€ì¤‘ì¹˜ ì¡°ì ˆ ê³„ìˆ˜ (ì´ ê°’ì„ ì¡°ì ˆí•˜ì—¬ í•™ìŠµ ì†ë„ë¥¼ ë³€ê²½í•˜ì„¸ìš”)
    const LEARNING_RATE = 0.5; 
    const MAX_SINGLE_WEIGHT = 1.5; // í•œ ë²ˆì˜ ìˆ˜ë¡œ ì¤„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ê°€ì¤‘ì¹˜ ë³€í™”ëŸ‰
  
  
    endgameMoves.forEach((move, i) => {
      
            const currentScore = move.evalScore;
            const prevScore = endgameMoves[i - 1].evalScore;
          
          
            // AI ê´€ì ì—ì„œì˜ ì‹¤ì œ ì´ë“ ê³„ì‚°
            const aiDelta = (aiColor === 'black') ? (currentScore - prevScore) : (prevScore - currentScore);
            const delta = Math.abs(aiDelta);

            console.log(`Move ${i} [Search Score]: ${prevScore.toFixed(2)} -> ${currentScore.toFixed(2)} | Delta: ${aiDelta.toFixed(2)}`);

            
            
          // ì¼ë°˜ì ì¸ ìƒí™©(1000 ì´í•˜) ë˜ëŠ” ì²´í¬ë©”ì´íŠ¸ ìƒí™©(9000 ì´ìƒ)ë§Œ í•™ìŠµ
            if (delta < 1000) {
              if (aiDelta < -1.0) { // íƒìƒ‰ ì ìˆ˜ ê¸°ë°˜ì´ë¯€ë¡œ ì„ê³„ê°’ì„ ì¡°ê¸ˆ ë” ì—„ê²©í•˜ê²Œ ì¡ì•„ë„ ë¨
                if (move.aiColor === aiColor) {
                    blunderCount++;
                  //////////////////////////applyWeightToDBì— move.searchDepthì¶”ê°€
                    applyWeightToDB(endgameMoves[i], -LEARNING_RATE*delta, move.searchDepth); // ë‚´ ìˆ˜ì½ê¸°ê°€ í‹€ë ¸ìœ¼ë¯€ë¡œ ì´ì „ ìˆ˜ì— ê°•í•œ í˜ë„í‹°
                  ////////////////////////////
                    console.log(`%c   -> Blunder at ${i} penalized.`, "color: #ff4d4d;");

                } else {
                    brilliantCount++;
                    applyWeightToDB(move, LEARNING_RATE*delta, move.searchDepth); // ìƒëŒ€ë°©ì´ ë‚´ ìˆ˜ì½ê¸°ë¥¼ ë›°ì–´ë„˜ì—ˆìœ¼ë¯€ë¡œ ìƒëŒ€ ìˆ˜ì— ê°•í•œ ê°€ì 
                    console.log(`%c   -> Brilliant move at ${i} rewarded.`, "color: #1a75ff;");
                    blunderCount++;
                    applyWeightToDB(endgameMoves[i - 1], -LEARNING_RATE*(delta/2), move.searchDepth);
                    console.log(`%c   -> Blunder at ${i-1} penalized.`, "color: #ff4d4d;");
                }
              }
            }
          if(delta > 50000){
            if (aiDelta < 0) { // íƒìƒ‰ ì ìˆ˜ ê¸°ë°˜ì´ë¯€ë¡œ ì„ê³„ê°’ì„ ì¡°ê¸ˆ ë” ì—„ê²©í•˜ê²Œ ì¡ì•„ë„ ë¨
                if (move.aiColor === aiColor) {
                    blunderCount++;
                    applyWeightToDB(endgameMoves[i], -MAX_SINGLE_WEIGHT, move.searchDepth); // ë‚´ ìˆ˜ì½ê¸°ê°€ í‹€ë ¸ìœ¼ë¯€ë¡œ ì´ì „ ìˆ˜ì— ê°•í•œ í˜ë„í‹°
                    console.log(`%c   -> Blunder at ${i} penalized.`, "color: #ff4d4d;");

                } else {
                    brilliantCount++;
                    applyWeightToDB(move, MAX_SINGLE_WEIGHT, move.searchDepth); // ìƒëŒ€ë°©ì´ ë‚´ ìˆ˜ì½ê¸°ë¥¼ ë›°ì–´ë„˜ì—ˆìœ¼ë¯€ë¡œ ìƒëŒ€ ìˆ˜ì— ê°•í•œ ê°€ì 
                    console.log(`%c   -> Brilliant move at ${i} rewarded.`, "color: #1a75ff;");
                    blunderCount++;
                    applyWeightToDB(endgameMoves[i - 1], -MAX_SINGLE_WEIGHT, move.searchDepth);
                    console.log(`%c   -> Blunder at ${i-1} penalized.`, "color: #ff4d4d;");
                }
              }
          }
      //2. ìµœì¢… ê²°ê³¼ì— ë”°ë¥¸ ë³´ìƒ (ê²Œì„ ì¢…ë£Œ ì‹œì ì— í•œ ë²ˆ ë” ë£¨í”„)
        if (winner === aiColor) {
            applyWeightToDB(move, 0.1, move.searchDepth); // ìŠ¹ë¦¬í•œ ê²Œì„ì˜ ëª¨ë“  ìˆ˜ì— ë¯¸ì„¸í•œ ë³´ìƒ
        } else if (winner !== 'draw') {
            applyWeightToDB(move, -0.1, move.searchDepth); // íŒ¨ë°°í•œ ê²Œì„ì˜ ëª¨ë“  ìˆ˜ì— ë¯¸ì„¸í•œ í˜ë„í‹°
        }
    });

    // ë°ì´í„° ì €ì¥
    saveLearningDB();

    const countAfter = getDBTotalCount(learningDB);
    const newScenarios = countAfter - countBefore;
  
    // --- ê°œì„ ëœ ê²°ê³¼ ë¦¬í¬íŠ¸ ì¶œë ¥ ---
    console.log(`%c[Learning Report]`, "color: #4CAF50; font-weight: bold; font-size: 12px;");
    console.log(`- Result: ${winner.toUpperCase()} wins`);
    console.log(`- %cBlunders identified: ${blunderCount}`, "color: #ff4d4d;");
    console.log(`- %cBrilliant moves identified: ${brilliantCount}`, "color: #1a75ff;");
    console.log(`- New scenarios added to DB: ${newScenarios}`);
    console.log(`- Total DB knowledge: ${countAfter} scenarios`);
    console.log(`-----------------------------------------`);
  } else {
        console.log("%c   -> [DB] Endgame DB ì €ì¥ì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤. (ê°€ì¤‘ì¹˜ë§Œ íŠœë‹ë¨)", "color: #ff9800;");
  }
  //ifë¬¸ìœ¼ë¡œ ê°ì‹¸ê¸°//////////////////////////////////
};

///////////////
const applyWeightToDB = (moveEntry, weight, depth) => {
    const moveKey = `${moveEntry.from.row}${moveEntry.from.col}${moveEntry.to.row}${moveEntry.to.col}`;
    
    // 1. ì›ë³¸ êµ­ë©´ ê¸°ë¡
    updateDB(moveEntry.boardHash, moveKey, weight, depth);

    // 2. ëŒ€ì¹­ êµ­ë©´ ê¸°ë¡
    if (moveEntry.mirroredHash) {
        const mirroredKey = getMirroredMoveKey(moveKey);
        updateDB(moveEntry.mirroredHash, mirroredKey, weight, depth);
    }
};
//////////////////

//////////////////
const updateDB = (hash, moveKey, weight, depth) => {
    if (!learningDB[hash]) learningDB[hash] = {};
    
    // ê¸°ì¡´ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
    const existing = learningDB[hash][moveKey]; // ì˜ˆ: [2.5, 4] (ê°€ì¤‘ì¹˜, ê¹Šì´)

    if (existing) {
        let [oldWeight, oldDepth] = existing;
        
        // [ì‹ ë¢°ë„ ë¡œì§] ìƒˆ ë°ì´í„°ì˜ ê¹Šì´ê°€ ë” ê¹Šë‹¤ë©´ ë” ë§ì´ ë°˜ì˜í•¨
        if (depth > oldDepth) {
            // ê¹Šì´ê°€ ë” ê¹Šì€ ë°ì´í„°ë¡œ ê°±ì‹ í•˜ê±°ë‚˜ ë†’ì€ ë¹„ì¤‘ìœ¼ë¡œ í•©ì‚°
            oldWeight = (oldWeight + weight * 1.5) / 2; 
            oldDepth = depth;
        } else {
            // ê¹Šì´ê°€ ë‚®ê±°ë‚˜ ê°™ë‹¤ë©´ ë¯¸ì„¸í•˜ê²Œë§Œ ë°˜ì˜
            oldWeight += weight * 0.5;
        }
        
        learningDB[hash][moveKey] = [
            Math.max(-10, Math.min(10, Math.round(oldWeight * 100) / 100)),
            oldDepth
        ];
    } else {
        // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
        learningDB[hash][moveKey] = [Math.round(weight * 100) / 100, depth];
    }
};
/////////////////


const getMirroredBoard = (boardState) => {
    return boardState.map(row => [...row].reverse());
};

const getMirroredMoveKey = (moveKey) => {
    // moveKey ì˜ˆì‹œ: "6444" (fromRow, fromCol, toRow, toCol)
    const fromRow = moveKey[0];
    const fromCol = 7 - parseInt(moveKey[1]);
    const toRow = moveKey[2];
    const toCol = 7 - parseInt(moveKey[3]);
    return `${fromRow}${fromCol}${toRow}${toCol}`;
};

//ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì˜ í•™ìŠµ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ëŠ” í•¨ìˆ˜
function clearAIDatabase() {
    if (confirm("ë¸Œë¼ìš°ì €ì˜ í•™ìŠµ ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì½”ë“œì˜ ê¸°ì´ˆ ì§€ì‹ì€ ìœ ì§€ë©ë‹ˆë‹¤.)")) {
        localStorage.removeItem('chess_learning_endgame_db');
        
        // ì¤‘ìš”: ë©”ëª¨ë¦¬ ìƒì˜ DBë„ ê¸°ì´ˆ ì§€ì‹ìœ¼ë¡œë§Œ ë¦¬ì…‹
        learningDB = JSON.parse(JSON.stringify(INITIAL_KNOWLEDGE));
        
        console.log("ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ê°€ ë¹„ì›Œì¡ŒìŠµë‹ˆë‹¤. AIê°€ INITIAL_KNOWLEDGE ìƒíƒœë¡œ ëŒì•„ê°”ìŠµë‹ˆë‹¤.");
        alert("ë¡œì»¬ ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
    }
}

// í•™ìŠµëœ ë°ì´í„°ë¥¼ ë©”ëª¨ì¥ìš© í…ìŠ¤íŠ¸ë¡œ ë‚´ë³´ë‚´ê¸°
function exportLearningDB() {
    // í˜„ì¬ ë©”ëª¨ë¦¬ì˜ learningDB(ê¸°ì´ˆ+í•™ìŠµ)ë¥¼ ëª¨ë‘ ì¶”ì¶œ
    const dataStr = JSON.stringify(learningDB, null, 4); 
    const blob = new Blob([dataStr], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    const now = new Date();
    const fileName = `chess_ai_full_db_${now.getMonth()+1}${now.getDate()}.txt`;
    
    link.href = url;
    link.download = fileName;
    link.click();
    URL.revokeObjectURL(url);
    console.log("ì „ì²´ DBê°€ ì¶”ì¶œë˜ì—ˆìŠµë‹ˆë‹¤. INITIAL_KNOWLEDGE ì—…ë°ì´íŠ¸ì— ì‚¬ìš©í•˜ì„¸ìš”.");
}

// ëª¨ë“œ ì „í™˜ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
aiMatchBtn.addEventListener('click', () => {
  //////////////
    if (isSelfPlayMode) stopSelfPlay(); // ìê°€ ëŒ€êµ­ ì¤‘ì´ë©´ ì¤‘ì§€ ë° ì „ì íŒ ìˆ¨ê¸°ê¸°
  ////////////
    gameMode = 'ai';
    aiMatchBtn.style.backgroundColor = '#779556';
    aiMatchBtn.style.color = 'white';
    pvpMatchBtn.style.backgroundColor = '';
    pvpMatchBtn.style.color = '';
    updateClockVisibility();
    resetGame();
});

pvpMatchBtn.addEventListener('click', () => {
  //////////////
    if (isSelfPlayMode) stopSelfPlay(); // ìê°€ ëŒ€êµ­ ì¤‘ì´ë©´ ì¤‘ì§€ ë° ì „ì íŒ ìˆ¨ê¸°ê¸°
  //////////////
    gameMode = 'pvp';
    pvpMatchBtn.style.backgroundColor = '#779556';
    pvpMatchBtn.style.color = 'white';
    aiMatchBtn.style.backgroundColor = '';
    aiMatchBtn.style.color = '';
    updateClockVisibility();
    resetGame();
});

// --- Event Listener ---
resetButton.addEventListener('click', resetGame);

// --- Initial Game Setup ---
resetGame(); // Start the first game

// ì„¤ì • ê´€ë ¨ DOM ìš”ì†Œ
const settingsBtn = document.getElementById('settingsBtn');
const settingsModal = document.getElementById('settingsModal');
const closeSettings = document.getElementById('closeSettings');

const midDepthRange = document.getElementById('midDepthRange');
const endDepthRange = document.getElementById('endDepthRange');
const midDepthVal = document.getElementById('midDepthVal');
const endDepthVal = document.getElementById('endDepthVal');
const drawWarningCheck = document.getElementById('drawWarningCheck');

// ì„¤ì •ì°½ ì—´ê¸°
settingsBtn.onclick = () => {
    settingsModal.style.display = "block";
    // ì„¤ì •ì°½ì´ ì—´ë¦¬ë©´ íƒ€ì´ë¨¸ë¥¼ ì¼ì‹œ ì •ì§€í•©ë‹ˆë‹¤.
    if (timers.interval) {
        clearInterval(timers.interval);
        console.log("Timer paused for settings.");
    }
};

// ì„¤ì •ì°½ ë‹«ê¸° (ì ìš© ë° ë‹«ê¸° ë²„íŠ¼)
closeSettings.onclick = () => {
    settingsModal.style.display = "none";
    // PvP ëª¨ë“œì´ê³  ê²Œì„ì´ ì§„í–‰ ì¤‘ì´ë¼ë©´ íƒ€ì´ë¨¸ë¥¼ ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤.
    if (!gameOver && gameMode === 'pvp' && timers.mode !== 'none') {
        startTimer();
        console.log("Timer resumed.");
    }
};

// 3. ë¯¸ë“¤ê²Œì„ Depth ì¡°ì ˆ
midDepthRange.oninput = function() {
    middlegame_depth = parseInt(this.value);
    midDepthVal.innerText = this.value;
    console.log(`Middlegame Depth changed to: ${middlegame_depth}`);
};

// 4. ì—”ë“œê²Œì„ Depth ì¡°ì ˆ
endDepthRange.oninput = function() {
    endgame_depth = parseInt(this.value);
    endDepthVal.innerText = this.value;
    console.log(`Endgame Depth changed to: ${endgame_depth}`);
};

// 5. ë¬´ìŠ¹ë¶€ ê²½ê³  í† ê¸€
drawWarningCheck.onchange = function() {
    showDrawWarnings = this.checked;
    console.log(`Show Draw Warnings: ${showDrawWarnings}`);
    // í˜„ì¬ í•˜ì´ë¼ì´íŠ¸ëœ ì¹¸ì´ ìˆë‹¤ë©´ ì¦‰ì‹œ ë°˜ì˜í•˜ê¸° ìœ„í•´ í˜¸ì¶œ ê°€ëŠ¥
    clearHighlightedMoves(); 
};

// ëª¨ë‹¬ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸° ë¡œì§ì—ë„ ì¶”ê°€
window.onclick = (event) => {
    if (event.target == settingsModal) {
        settingsModal.style.display = "none";
        if (!gameOver && gameMode === 'pvp' && timers.mode !== 'none') {
            startTimer();
        }
    }
};

// --- ì„¤ì •ì°½ ë¡œì§ ---
const timeModeSelect = document.getElementById('timeControlMode');
const timeSettings = document.getElementById('timeSettings');
const baseTimeRange = document.getElementById('baseTimeRange');
const incTimeRange = document.getElementById('incTimeRange');

// ê¸°ì¤€ ì‹œê°„(ë¶„) ìŠ¬ë¼ì´ë” ë¡œì§
baseTimeRange.oninput = function() {
    const newBaseMins = parseInt(this.value);
    const newBaseSecs = newBaseMins * 60;
    
    // 1. ê¸°ì¡´ ê¸°ì¤€ ì‹œê°„ê³¼ ìƒˆ ê¸°ì¤€ ì‹œê°„ì˜ ì°¨ì´ ê³„ì‚°
    const timeDifference = newBaseSecs - timers.base;
    
    // 2. í˜„ì¬ ë‚¨ì€ ì‹œê°„(white, black)ì— ì°¨ì´ë§Œí¼ ì ìš©
    // (ë‚¨ì€ ì‹œê°„ì´ 0 ì´í•˜ê°€ ë˜ì§€ ì•Šë„ë¡ Math.max ì‚¬ìš©)
    timers.white = Math.max(1, timers.white + timeDifference);
    timers.black = Math.max(1, timers.black + timeDifference);
    
    // 3. ê¸°ì¤€ê°’ ì—…ë°ì´íŠ¸
    timers.base = newBaseSecs;
    document.getElementById('baseTimeVal').innerText = newBaseMins;
    
    // 4. ì‹œê³„ ì¦‰ì‹œ ê°±ì‹ 
    updateClockDisplay();
    console.log(`Time updated: Added ${timeDifference}s to both players.`);
};

// ì¶”ê°€/ìœ ì˜ˆ ì‹œê°„(ì´ˆ) ìŠ¬ë¼ì´ë” ë¡œì§
incTimeRange.oninput = function() {
    timers.increment = parseInt(this.value); // ë¬¸ìì—´ ë°©ì§€
    document.getElementById('incTimeVal').innerText = this.value;
};

// ì‹œê°„ ëª¨ë“œ(Select box) ë³€ê²½ ì‹œ
timeModeSelect.onchange = function() {
    timers.mode = this.value;
    
    // 1. UI í‘œì‹œ ì„¤ì •
    timeSettings.style.display = timers.mode === 'none' ? 'none' : 'block';
    updateClockVisibility(); 
    
    // 2. í•µì‹¬: ëª¨ë“œê°€ ë°”ë€Œë©´ ì‹œê°„ì„ ì¦‰ì‹œ ì´ˆê¸°í™”
    resetTimers();
    
    console.log(`Time mode changed to ${timers.mode}. Clocks reset to ${timers.base}s.`);
};

// --- ì‹œê³„ ì‘ë™ ë¡œì§ ---

function updateClockDisplay() {
    const format = (s) => {
        const mins = Math.floor(s / 60);
        const secs = s % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    };
    
    document.getElementById('whiteClock').innerText = `White: ${format(timers.white)}`;
    document.getElementById('blackClock').innerText = `Black: ${format(timers.black)}`;
    
    // í™œì„±í™” í‘œì‹œ
    document.getElementById('whiteClock').classList.toggle('active', currentTurn === 'white');
    document.getElementById('blackClock').classList.toggle('active', currentTurn === 'black');
}

// 1. íƒ€ì´ë¨¸ ì‹œì‘ ë° ë”œë ˆì´ ì²˜ë¦¬
function startTimer() {
    // AI ëª¨ë“œì´ê±°ë‚˜ ì‹œê°„ ì œí•œ ì—†ìŒ, ë˜ëŠ” ê²Œì„ ì¢…ë£Œ ì‹œ íƒ€ì´ë¨¸ ì¤‘ì§€
    if (gameMode === 'ai' || timers.mode === 'none' || gameOver) {
        if (timers.interval) clearInterval(timers.interval);
        return;
    }

    clearInterval(timers.interval); // ê¸°ì¡´ ì¸í„°ë²Œ ì œê±°

    // [ì¤‘ìš”] ë”œë ˆì´ ëª¨ë“œë¼ë©´ í„´ì´ ì‹œì‘ë  ë•Œë§ˆë‹¤ ìœ ì˜ˆ ì‹œê°„ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
    if (timers.mode === 'delay') {
        timers.currentDelay = timers.increment; 
    }

    timers.interval = setInterval(() => {
        // [ë”œë ˆì´ ë¡œì§] ìœ ì˜ˆ ì‹œê°„ì´ ë‚¨ì•„ìˆë‹¤ë©´ ë³¸ ì‹œê°„ì„ ê¹ì§€ ì•Šê³  ìœ ì˜ˆ ì‹œê°„ë§Œ ì¤„ì„
        if (timers.mode === 'delay' && timers.currentDelay > 0) {
            timers.currentDelay--;
            // ìœ ì˜ˆ ì‹œê°„ì´ íë¥´ëŠ” ë™ì•ˆì€ ì‹œê³„ UIì— ë³€í™”ê°€ ì—†ìœ¼ë¯€ë¡œ ì—…ë°ì´íŠ¸ë¥¼ ìƒëµí•˜ê±°ë‚˜ 
            // ì‹œê³„ ì˜†ì— 'Delay' í‘œì‹œë¥¼ í•´ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            return; 
        }

        // [ë³¸ ì‹œê°„ ì°¨ê° ë¡œì§]
        if (currentTurn === 'white') {
            timers.white--;
            if (timers.white <= 0) endGameByTime('white');
        } else {
            timers.black--;
            if (timers.black <= 0) endGameByTime('black');
        }
        updateClockDisplay();
    }, 1000);
}

// 2. í„´ êµì²´ ì‹œ ì‹œê°„ ë³´ë„ˆìŠ¤ ì²˜ë¦¬ (í”¼ì…”)
function handleTimerOnTurnSwitch(previousTurnColor) {
    if (timers.mode === 'none' || gameMode === 'ai') return;

    // [í”¼ì…” ë¡œì§] ìˆ˜ë¥¼ ì™„ë£Œí•œ ì‚¬ëŒì—ê²Œ ì„¤ì •ëœ ì´ˆë§Œí¼ ë³´ë„ˆìŠ¤ ì¶”ê°€
    if (timers.mode === 'fisher') {
        timers[previousTurnColor] += timers.increment;
    }

    // ë‹¤ìŒ ì‚¬ëŒì„ ìœ„í•´ íƒ€ì´ë¨¸ë¥¼ ìƒˆë¡œ ì‹œì‘ (ë”œë ˆì´ ì´ˆê¸°í™” í¬í•¨)
    startTimer();
    updateClockDisplay();
}

function endGameByTime(loserColor) {
    clearInterval(timers.interval);
    gameOver = true;
    const winner = loserColor === 'white' ? 'Black' : 'White';
    statusDisplay.textContent = `Time Out! ${winner} wins!`;
    alert(`${winner} wins on time!`);
}

// resetGame í•¨ìˆ˜ ì•ˆì— ì¶”ê°€
function resetTimers() {
    clearInterval(timers.interval); // í˜„ì¬ ëŒì•„ê°€ëŠ” íƒ€ì´ë¨¸ ì¤‘ì§€
    timers.white = timers.base;    // í˜„ì¬ ì‹œê°„ì„ ì„¤ì •ëœ ê¸°ë³¸ ì‹œê°„ìœ¼ë¡œ ì´ˆê¸°í™”
    timers.black = timers.base;
    timers.currentDelay = 0;       // ë”œë ˆì´ ê¸°ë¡ ì´ˆê¸°í™”
    
    updateClockDisplay();          // ì‹œê³„ UI ì—…ë°ì´íŠ¸
    
    // PvP ëª¨ë“œì´ê³  ì‹œê°„ ì œí•œì´ ìˆëŠ” ìƒíƒœë¼ë©´ ë‹¤ì‹œ íƒ€ì´ë¨¸ ì‹œì‘
    if (!gameOver && gameMode === 'pvp' && timers.mode !== 'none') {
        startTimer();
    }
}

// ì‹œê³„ í‘œì‹œ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateClockVisibility() {
    const clockContainer = document.querySelector('.chess-clocks');
    if (!clockContainer) return;

    if (gameMode === 'ai' || timers.mode === 'none') {
        clockContainer.style.display = 'none';
        clearInterval(timers.interval); // AI ëª¨ë“œë©´ íƒ€ì´ë¨¸ ì¤‘ì§€
    } else {
        clockContainer.style.display = 'flex';
        // PvP ëª¨ë“œê³  ì‹œê°„ ì œí•œì´ ì„¤ì •ë˜ì–´ ìˆë‹¤ë©´ íƒ€ì´ë¨¸ ì‹œì‘ ê³ ë ¤
        if (!gameOver) startTimer(); 
    }
}

const boardThemes = {
    forest: { dark: '#779556', light: '#ebecd0' },
    ocean: { dark: '#4b7399', light: '#eae9d2' },
    tournament: { dark: '#b58863', light: '#f0d9b5' },
    midnight: { dark: '#51504e', light: '#aeab9d' },
    vintage: { dark: '#8b4513', light: '#d2b48c' }
};

const boardThemeSelect = document.getElementById('boardThemeSelect');

boardThemeSelect.onchange = function() {
    const theme = boardThemes[this.value];
    
    // CSS ë³€ìˆ˜ êµì²´
    document.documentElement.style.setProperty('--dark-color', theme.dark);
    document.documentElement.style.setProperty('--light-color', theme.light);
    
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥ (ë‹¤ìŒ ì ‘ì† ì‹œ ìœ ì§€)
    localStorage.setItem('chess_theme', this.value);
    
    console.log(`Board theme changed to: ${this.value}`);
};

// í˜ì´ì§€ ë¡œë“œ ì‹œ ì €ì¥ëœ í…Œë§ˆ ë¶ˆëŸ¬ì˜¤ê¸°
window.addEventListener('DOMContentLoaded', () => {
    const savedTheme = localStorage.getItem('chess_theme') || 'forest';
    boardThemeSelect.value = savedTheme;
    boardThemeSelect.dispatchEvent(new Event('change'));
});

const openingBookCheck = document.getElementById('openingBookCheck');

openingBookCheck.onchange = function() {
    useOpeningBook = this.checked;
    console.log(`AI Opening Book Enabled: ${useOpeningBook}`);
};

///////////////////////

/**
 * ìê°€ ëŒ€êµ­ ì‹œì‘ í•¨ìˆ˜ (í™•ì¥íŒ)
 * @param {number} totalGames - ë°˜ë³µí•  ì´ ëŒ€êµ­ ìˆ˜
 * @param {number} midDepth - ì„¤ì •í•  ë¯¸ë“¤ê²Œì„ íƒìƒ‰ ê¹Šì´
 * @param {number} endDepth - ì„¤ì •í•  ì—”ë“œê²Œì„ íƒìƒ‰ ê¹Šì´
 * @param {number} speed - ìˆ˜ ì‚¬ì´ì˜ ë”œë ˆì´ (ms)
 */
function startSelfPlay(totalGames = 1, midDepth = 3, endDepth = 5, speed = 50) {
    isSelfPlayMode = true;
    remainingSelfPlayGames = totalGames;
    selfPlayDelay = speed;
    gameMode = 'ai';
  
    // ì „ì  ì´ˆê¸°í™”
    selfPlayResults = { white: 0, black: 0, draw: 0, totalCompleted: 0, targetGames: totalGames };
    
    // UI í‘œì‹œ
    document.getElementById('selfPlayDashboard').style.display = 'block';
    updateScoreboardUI();

    // ëìŠ¤ ì„¤ì • ë°˜ì˜
    middlegame_depth = midDepth;
    endgame_depth = endDepth;

    console.log(`%c[Self-Play] ìê°€ í•™ìŠµ ëª¨ë“œ í™œì„±í™”`, "color: #4CAF50; font-weight: bold;");
    console.log(`- ëª©í‘œ ëŒ€êµ­ ìˆ˜: ${totalGames}íŒ`);
    console.log(`- ì„¤ì • ëìŠ¤: ë¯¸ë“¤(${midDepth}) / ì—”ë“œ(${endDepth})`);
    console.log(`- ì´ë™ ì†ë„: ${speed}ms`);

    // ì¦‰ì‹œ ì²« ê²Œì„ ì‹œì‘
    resetGame();
}
//startSelfPlay(1,3,3,250)

function stopSelfPlay() {
    isSelfPlayMode = false;
    remainingSelfPlayGames = 0; // ëŒ€êµ­ ì˜ˆì•½ ì·¨ì†Œ
  
    // [ì¶”ê°€] ìê°€ ëŒ€êµ­ ëŒ€ì‹œë³´ë“œ ìˆ¨ê¸°ê¸°
    const dashboard = document.getElementById('selfPlayDashboard');
    if (dashboard) {
        dashboard.style.display = 'none';
    }
  
    console.log("%c[Self-Play] ìê°€ ëŒ€êµ­ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.", "color: #f44336; font-weight: bold;");
  
    // ê²°ê³¼ ìš”ì•½ ì¶œë ¥
    console.table({
        "ë°± ìŠ¹": selfPlayResults.white,
        "í‘ ìŠ¹": selfPlayResults.black,
        "ë¬´ìŠ¹ë¶€": selfPlayResults.draw,
        "ì´ ëŒ€êµ­": selfPlayResults.totalCompleted
    });
}

/**
 * ìê°€ ëŒ€êµ­ ìƒíƒœì—ì„œ AIì˜ ìƒ‰ìƒì„ ìë™ìœ¼ë¡œ ì „í™˜í•´ì£¼ëŠ” ë˜í¼ í•¨ìˆ˜
 */
function triggerNextSelfMove() {
    if (!isSelfPlayMode || gameOver) return;
    
    // ìê°€ ëŒ€êµ­ ì¤‘ì—ëŠ” í˜„ì¬ í„´ì„ ë¬´ì¡°ê±´ AI ìƒ‰ìƒìœ¼ë¡œ ê°„ì£¼
    aiColor = currentTurn;
    setTimeout(aiMove, selfPlayDelay);
}

/**
 * í•™ìŠµëœ ëª¨ë“  ê°€ì¤‘ì¹˜ë¥¼ ì´ˆê¸°í™”í•˜ê³  ê²Œì„ì„ ë¦¬ì…‹í•©ë‹ˆë‹¤.
 * (CodePen í˜¸í™˜ ë²„ì „)
 */
function resetAITuning() {
    if (confirm("AIì˜ ëª¨ë“  ê°€ì¤‘ì¹˜ í•™ìŠµ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
        // 1. ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì‚­ì œ
        localStorage.removeItem('chess_eval_weights');
        
        // 2. í˜„ì¬ ë©”ëª¨ë¦¬ì˜ ê°€ì¤‘ì¹˜ë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ ë®ì–´ì”Œì›€
        // (ê¹Šì€ ë³µì‚¬ë¥¼ ìœ„í•´ JSON ë°©ì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤)
        eval_weights = JSON.parse(JSON.stringify(DEFAULT_EVAL_WEIGHTS));
        
        // 3. í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ê²Œì„ì´ ìˆë‹¤ë©´ ì´ˆê¸°í™”
        resetGame();
        
        console.log("%c[System] AI ê°€ì¤‘ì¹˜ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.", "color: #f44336; font-weight: bold;");
        alert("AI ê°€ì¤‘ì¹˜ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
    }
}

/**
 * í˜„ì¬ í•™ìŠµëœ ê°€ì¤‘ì¹˜ ìƒíƒœë¥¼ ì½˜ì†”ì— ì¶œë ¥í•©ë‹ˆë‹¤.
 */
function showCurrentWeights() {
    console.log(JSON.stringify(eval_weights, null, 2));
}

/**
 * Endgame DB ì €ì¥ ê¸°ëŠ¥ì„ ì¼œê±°ë‚˜ ë•ë‹ˆë‹¤.
 * @param {boolean} enable - true(ì¼œê¸°), false(ë„ê¸°)
 */
function toggleEndgameDB(enable) {
    isEndgameDBEnabled = enable;
    const status = enable ? "í™œì„±í™”" : "ë¹„í™œì„±í™”";
    const color = enable ? "#4CAF50" : "#f44336";
    console.log(`%c[System] Endgame DB ì €ì¥ì´ ${status}ë˜ì—ˆìŠµë‹ˆë‹¤.`, `color: ${color}; font-weight: bold;`);
}

/**
 * Self-Tuning(ê°€ì¤‘ì¹˜ í•™ìŠµ) ê¸°ëŠ¥ì„ ì¼œê±°ë‚˜ ë•ë‹ˆë‹¤.
 * @param {boolean} enable - true(ì¼œê¸°), false(ë„ê¸°)
 */
function toggleSelfTuning(enable) {
    isSelfTuningEnabled = enable;
    const status = enable ? "í™œì„±í™”" : "ë¹„í™œì„±í™”";
    const color = enable ? "#4CAF50" : "#f44336";
    console.log(`%c[System] ê°€ì¤‘ì¹˜ íŒŒì¸ íŠœë‹ í•™ìŠµì´ ${status}ë˜ì—ˆìŠµë‹ˆë‹¤.`, `color: ${color}; font-weight: bold;`);
}

// ì „ì  UI ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateScoreboardUI() {
    document.getElementById('whiteWins').textContent = selfPlayResults.white;
    document.getElementById('blackWins').textContent = selfPlayResults.black;
    document.getElementById('drawCount').textContent = selfPlayResults.draw;
    document.getElementById('currentGameNum').textContent = selfPlayResults.totalCompleted;
    document.getElementById('totalTargetGames').textContent = selfPlayResults.targetGames;

    // ìŠ¹ë¥  ê³„ì‚° (ë°± ê¸°ì¤€ ìŠ¹ë¥  ì˜ˆì‹œ)
    if (selfPlayResults.totalCompleted > 0) {
        const rate = ((selfPlayResults.white + (selfPlayResults.draw * 0.5)) / selfPlayResults.totalCompleted * 100).toFixed(1);
        document.getElementById('winRate').textContent = rate + "%";
    }
}
//////////////////////
